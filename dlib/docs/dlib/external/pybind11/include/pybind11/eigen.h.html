<html><!-- Created using the cpp_pretty_printer from the dlib C++ library.  See http://dlib.net for updates. --><head><title>dlib C++ Library - eigen.h</title></head><body bgcolor='white'><pre>
<font color='#009900'>/*
    pybind11/eigen.h: Transparent conversion for dense and sparse Eigen matrices

    Copyright (c) 2016 Wenzel Jakob &lt;wenzel.jakob@epfl.ch&gt;

    All rights reserved. Use of this source code is governed by a
    BSD-style license that can be found in the LICENSE file.
*/</font>

<font color='#0000FF'>#pragma</font> once

<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='numpy.h.html'>numpy.h</a>"

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>__INTEL_COMPILER<font face='Lucida Console'>)</font>
#  pragma <b><a name='warning'></a>warning</b><font face='Lucida Console'>(</font>disable: <font color='#979000'>1682</font><font face='Lucida Console'>)</font> <font color='#009900'>// implicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem)
</font><font color='#0000FF'>#elif</font> defined<font face='Lucida Console'>(</font>__GNUG__<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> defined<font face='Lucida Console'>(</font>__clang__<font face='Lucida Console'>)</font>
#  pragma GCC diagnostic push
#  pragma GCC diagnostic ignored "<font color='#CC0000'>-Wconversion</font>"
#  pragma GCC diagnostic ignored "<font color='#CC0000'>-Wdeprecated-declarations</font>"
#  ifdef __clang__
<font color='#009900'>//   Eigen generates a bunch of implicit-copy-constructor-is-deprecated warnings with -Wdeprecated
</font><font color='#009900'>//   under Clang, so disable that warning here:
</font>#    pragma GCC diagnostic ignored "<font color='#CC0000'>-Wdeprecated</font>"
#  endif
#  <font color='#0000FF'>if</font> __GNUC__ <font color='#5555FF'>&gt;</font><font color='#5555FF'>=</font> <font color='#979000'>7</font>
#    pragma GCC diagnostic ignored "<font color='#CC0000'>-Wint-in-bool-context</font>"
#  endif
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>Eigen<font color='#5555FF'>/</font>Core<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>Eigen<font color='#5555FF'>/</font>SparseCore<font color='#5555FF'>&gt;</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>_MSC_VER<font face='Lucida Console'>)</font>
#  pragma <b><a name='warning'></a>warning</b><font face='Lucida Console'>(</font>push<font face='Lucida Console'>)</font>
#  pragma <b><a name='warning'></a>warning</b><font face='Lucida Console'>(</font>disable: <font color='#979000'>4127</font><font face='Lucida Console'>)</font> <font color='#009900'>// warning C4127: Conditional expression is constant
</font><font color='#0000FF'>#endif</font>

<font color='#009900'>// Eigen prior to 3.2.7 doesn't have proper move constructors--but worse, some classes get implicit
</font><font color='#009900'>// move constructors that break things.  We could detect this an explicitly copy, but an extra copy
</font><font color='#009900'>// of matrices seems highly undesirable.
</font><b><a name='static_assert'></a>static_assert</b><font face='Lucida Console'>(</font><font color='#BB00BB'>EIGEN_VERSION_AT_LEAST</font><font face='Lucida Console'>(</font><font color='#979000'>3</font>,<font color='#979000'>2</font>,<font color='#979000'>7</font><font face='Lucida Console'>)</font>, "<font color='#CC0000'>Eigen support in pybind11 requires Eigen &gt;= 3.2.7</font>"<font face='Lucida Console'>)</font>;

<b><a name='NAMESPACE_BEGIN'></a>NAMESPACE_BEGIN</b><font face='Lucida Console'>(</font>PYBIND11_NAMESPACE<font face='Lucida Console'>)</font>

<font color='#009900'>// Provide a convenience alias for easier pass-by-ref usage with fully dynamic strides:
</font><font color='#0000FF'>using</font> EigenDStride <font color='#5555FF'>=</font> Eigen::Stride<font color='#5555FF'>&lt;</font>Eigen::Dynamic, Eigen::Dynamic<font color='#5555FF'>&gt;</font>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> MatrixType<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> EigenDRef <font color='#5555FF'>=</font> Eigen::Ref<font color='#5555FF'>&lt;</font>MatrixType, <font color='#979000'>0</font>, EigenDStride<font color='#5555FF'>&gt;</font>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> MatrixType<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> EigenDMap <font color='#5555FF'>=</font> Eigen::Map<font color='#5555FF'>&lt;</font>MatrixType, <font color='#979000'>0</font>, EigenDStride<font color='#5555FF'>&gt;</font>;

<b><a name='NAMESPACE_BEGIN'></a>NAMESPACE_BEGIN</b><font face='Lucida Console'>(</font>detail<font face='Lucida Console'>)</font>

<font color='#0000FF'>#if</font> EIGEN_VERSION_AT_LEAST<font face='Lucida Console'>(</font><font color='#979000'>3</font>,<font color='#979000'>3</font>,<font color='#979000'>0</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>using</font> EigenIndex <font color='#5555FF'>=</font> Eigen::Index;
<font color='#0000FF'>#else</font>
<font color='#0000FF'>using</font> EigenIndex <font color='#5555FF'>=</font> EIGEN_DEFAULT_DENSE_INDEX_TYPE;
<font color='#0000FF'>#endif</font>

<font color='#009900'>// Matches Eigen::Map, Eigen::Ref, blocks, etc:
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> is_eigen_dense_map <font color='#5555FF'>=</font> all_of<font color='#5555FF'>&lt;</font>is_template_base_of<font color='#5555FF'>&lt;</font>Eigen::DenseBase, T<font color='#5555FF'>&gt;</font>, std::is_base_of<font color='#5555FF'>&lt;</font>Eigen::MapBase<font color='#5555FF'>&lt;</font>T, Eigen::ReadOnlyAccessors<font color='#5555FF'>&gt;</font>, T<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> is_eigen_mutable_map <font color='#5555FF'>=</font> std::is_base_of<font color='#5555FF'>&lt;</font>Eigen::MapBase<font color='#5555FF'>&lt;</font>T, Eigen::WriteAccessors<font color='#5555FF'>&gt;</font>, T<font color='#5555FF'>&gt;</font>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> is_eigen_dense_plain <font color='#5555FF'>=</font> all_of<font color='#5555FF'>&lt;</font>negation<font color='#5555FF'>&lt;</font>is_eigen_dense_map<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>, is_template_base_of<font color='#5555FF'>&lt;</font>Eigen::PlainObjectBase, T<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> is_eigen_sparse <font color='#5555FF'>=</font> is_template_base_of<font color='#5555FF'>&lt;</font>Eigen::SparseMatrixBase, T<font color='#5555FF'>&gt;</font>;
<font color='#009900'>// Test for objects inheriting from EigenBase&lt;Derived&gt; that aren't captured by the above.  This
</font><font color='#009900'>// basically covers anything that can be assigned to a dense matrix but that don't have a typical
</font><font color='#009900'>// matrix data layout that can be copied from their .data().  For example, DiagonalMatrix and
</font><font color='#009900'>// SelfAdjointView fall into this category.
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> is_eigen_other <font color='#5555FF'>=</font> all_of<font color='#5555FF'>&lt;</font>
    is_template_base_of<font color='#5555FF'>&lt;</font>Eigen::EigenBase, T<font color='#5555FF'>&gt;</font>,
    negation<font color='#5555FF'>&lt;</font>any_of<font color='#5555FF'>&lt;</font>is_eigen_dense_map<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>, is_eigen_dense_plain<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>, is_eigen_sparse<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>
<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// Captures numpy/eigen conformability status (returned by EigenProps::conformable()):
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'><u>bool</u></font> EigenRowMajor<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='EigenConformable'></a>EigenConformable</b> <b>{</b>
    <font color='#0000FF'><u>bool</u></font> conformable <font color='#5555FF'>=</font> <font color='#979000'>false</font>;
    EigenIndex rows <font color='#5555FF'>=</font> <font color='#979000'>0</font>, cols <font color='#5555FF'>=</font> <font color='#979000'>0</font>;
    EigenDStride stride<b>{</b><font color='#979000'>0</font>, <font color='#979000'>0</font><b>}</b>;      <font color='#009900'>// Only valid if negativestrides is false!
</font>    <font color='#0000FF'><u>bool</u></font> negativestrides <font color='#5555FF'>=</font> <font color='#979000'>false</font>;   <font color='#009900'>// If true, do not use stride!
</font>
    <b><a name='EigenConformable'></a>EigenConformable</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>bool</u></font> fits <font color='#5555FF'>=</font> <font color='#979000'>false</font><font face='Lucida Console'>)</font> : conformable<b>{</b>fits<b>}</b> <b>{</b><b>}</b>
    <font color='#009900'>// Matrix type:
</font>    <b><a name='EigenConformable'></a>EigenConformable</b><font face='Lucida Console'>(</font>EigenIndex r, EigenIndex c,
            EigenIndex rstride, EigenIndex cstride<font face='Lucida Console'>)</font> :
        conformable<b>{</b><font color='#979000'>true</font><b>}</b>, rows<b>{</b>r<b>}</b>, cols<b>{</b>c<b>}</b> <b>{</b>
        <font color='#009900'>// TODO: when Eigen bug #747 is fixed, remove the tests for non-negativity. http://eigen.tuxfamily.org/bz/show_bug.cgi?id=747
</font>        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>rstride <font color='#5555FF'>&lt;</font> <font color='#979000'>0</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> cstride <font color='#5555FF'>&lt;</font> <font color='#979000'>0</font><font face='Lucida Console'>)</font> <b>{</b>
            negativestrides <font color='#5555FF'>=</font> <font color='#979000'>true</font>;
        <b>}</b> <font color='#0000FF'>else</font> <b>{</b>
            stride <font color='#5555FF'>=</font> <b>{</b>EigenRowMajor ? rstride : cstride <font color='#009900'>/* outer stride */</font>,
                      EigenRowMajor ? cstride : rstride <font color='#009900'>/* inner stride */</font> <b>}</b>;
        <b>}</b>
    <b>}</b>
    <font color='#009900'>// Vector type:
</font>    <b><a name='EigenConformable'></a>EigenConformable</b><font face='Lucida Console'>(</font>EigenIndex r, EigenIndex c, EigenIndex stride<font face='Lucida Console'>)</font>
        : EigenConformable<font face='Lucida Console'>(</font>r, c, r <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>1</font> ? c<font color='#5555FF'>*</font>stride : stride, c <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>1</font> ? r : r<font color='#5555FF'>*</font>stride<font face='Lucida Console'>)</font> <b>{</b><b>}</b>

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> props<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>bool</u></font> <b><a name='stride_compatible'></a>stride_compatible</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font> <b>{</b>
        <font color='#009900'>// To have compatible strides, we need (on both dimensions) one of fully dynamic strides,
</font>        <font color='#009900'>// matching strides, or a dimension size of 1 (in which case the stride value is irrelevant)
</font>        <font color='#0000FF'>return</font>
            <font color='#5555FF'>!</font>negativestrides <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font>
            <font face='Lucida Console'>(</font>props::inner_stride <font color='#5555FF'>=</font><font color='#5555FF'>=</font> Eigen::Dynamic <font color='#5555FF'>|</font><font color='#5555FF'>|</font> props::inner_stride <font color='#5555FF'>=</font><font color='#5555FF'>=</font> stride.<font color='#BB00BB'>inner</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font>
                <font face='Lucida Console'>(</font>EigenRowMajor ? cols : rows<font face='Lucida Console'>)</font> <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>1</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font>
            <font face='Lucida Console'>(</font>props::outer_stride <font color='#5555FF'>=</font><font color='#5555FF'>=</font> Eigen::Dynamic <font color='#5555FF'>|</font><font color='#5555FF'>|</font> props::outer_stride <font color='#5555FF'>=</font><font color='#5555FF'>=</font> stride.<font color='#BB00BB'>outer</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font>
                <font face='Lucida Console'>(</font>EigenRowMajor ? rows : cols<font face='Lucida Console'>)</font> <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>1</font><font face='Lucida Console'>)</font>;
    <b>}</b>
    <b><a name='operator'></a>operator</b> <font color='#0000FF'><u>bool</u></font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font> <b>{</b> <font color='#0000FF'>return</font> conformable; <b>}</b>
<b>}</b>;

<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> Type<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='eigen_extract_stride'></a>eigen_extract_stride</b> <b>{</b> <font color='#0000FF'>using</font> type <font color='#5555FF'>=</font> Type; <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> PlainObjectType, <font color='#0000FF'><u>int</u></font> MapOptions, <font color='#0000FF'>typename</font> StrideType<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='eigen_extract_stride'></a>eigen_extract_stride</b><font color='#5555FF'>&lt;</font>Eigen::Map<font color='#5555FF'>&lt;</font>PlainObjectType, MapOptions, StrideType<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <b>{</b> <font color='#0000FF'>using</font> type <font color='#5555FF'>=</font> StrideType; <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> PlainObjectType, <font color='#0000FF'><u>int</u></font> Options, <font color='#0000FF'>typename</font> StrideType<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='eigen_extract_stride'></a>eigen_extract_stride</b><font color='#5555FF'>&lt;</font>Eigen::Ref<font color='#5555FF'>&lt;</font>PlainObjectType, Options, StrideType<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <b>{</b> <font color='#0000FF'>using</font> type <font color='#5555FF'>=</font> StrideType; <b>}</b>;

<font color='#009900'>// Helper struct for extracting information from an Eigen type
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> Type_<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='EigenProps'></a>EigenProps</b> <b>{</b>
    <font color='#0000FF'>using</font> Type <font color='#5555FF'>=</font> Type_;
    <font color='#0000FF'>using</font> Scalar <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> Type::Scalar;
    <font color='#0000FF'>using</font> StrideType <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> eigen_extract_stride<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font>::type;
    <font color='#0000FF'>static</font> constexpr EigenIndex
        rows <font color='#5555FF'>=</font> Type::RowsAtCompileTime,
        cols <font color='#5555FF'>=</font> Type::ColsAtCompileTime,
        size <font color='#5555FF'>=</font> Type::SizeAtCompileTime;
    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'><u>bool</u></font>
        row_major <font color='#5555FF'>=</font> Type::IsRowMajor,
        vector <font color='#5555FF'>=</font> Type::IsVectorAtCompileTime, <font color='#009900'>// At least one dimension has fixed size 1
</font>        fixed_rows <font color='#5555FF'>=</font> rows <font color='#5555FF'>!</font><font color='#5555FF'>=</font> Eigen::Dynamic,
        fixed_cols <font color='#5555FF'>=</font> cols <font color='#5555FF'>!</font><font color='#5555FF'>=</font> Eigen::Dynamic,
        fixed <font color='#5555FF'>=</font> size <font color='#5555FF'>!</font><font color='#5555FF'>=</font> Eigen::Dynamic, <font color='#009900'>// Fully-fixed size
</font>        dynamic <font color='#5555FF'>=</font> <font color='#5555FF'>!</font>fixed_rows <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> <font color='#5555FF'>!</font>fixed_cols; <font color='#009900'>// Fully-dynamic size
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>EigenIndex i, EigenIndex ifzero<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> if_zero <font color='#5555FF'>=</font> std::integral_constant<font color='#5555FF'>&lt;</font>EigenIndex, i <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>0</font> ? ifzero : i<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>static</font> constexpr EigenIndex inner_stride <font color='#5555FF'>=</font> if_zero<font color='#5555FF'>&lt;</font>StrideType::InnerStrideAtCompileTime, <font color='#979000'>1</font><font color='#5555FF'>&gt;</font>::value,
                                outer_stride <font color='#5555FF'>=</font> if_zero<font color='#5555FF'>&lt;</font>StrideType::OuterStrideAtCompileTime,
                                                       vector ? size : row_major ? cols : rows<font color='#5555FF'>&gt;</font>::value;
    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'><u>bool</u></font> dynamic_stride <font color='#5555FF'>=</font> inner_stride <font color='#5555FF'>=</font><font color='#5555FF'>=</font> Eigen::Dynamic <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> outer_stride <font color='#5555FF'>=</font><font color='#5555FF'>=</font> Eigen::Dynamic;
    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'><u>bool</u></font> requires_row_major <font color='#5555FF'>=</font> <font color='#5555FF'>!</font>dynamic_stride <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> <font color='#5555FF'>!</font>vector <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> <font face='Lucida Console'>(</font>row_major ? inner_stride : outer_stride<font face='Lucida Console'>)</font> <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>1</font>;
    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'><u>bool</u></font> requires_col_major <font color='#5555FF'>=</font> <font color='#5555FF'>!</font>dynamic_stride <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> <font color='#5555FF'>!</font>vector <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> <font face='Lucida Console'>(</font>row_major ? outer_stride : inner_stride<font face='Lucida Console'>)</font> <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>1</font>;

    <font color='#009900'>// Takes an input array and determines whether we can make it fit into the Eigen type.  If
</font>    <font color='#009900'>// the array is a vector, we attempt to fit it into either an Eigen 1xN or Nx1 vector
</font>    <font color='#009900'>// (preferring the latter if it will fit in either, i.e. for a fully dynamic matrix type).
</font>    <font color='#0000FF'>static</font> EigenConformable<font color='#5555FF'>&lt;</font>row_major<font color='#5555FF'>&gt;</font> <b><a name='conformable'></a>conformable</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> array <font color='#5555FF'>&amp;</font>a<font face='Lucida Console'>)</font> <b>{</b>
        <font color='#0000FF'>const</font> <font color='#0000FF'>auto</font> dims <font color='#5555FF'>=</font> a.<font color='#BB00BB'>ndim</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>dims <font color='#5555FF'>&lt;</font> <font color='#979000'>1</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> dims <font color='#5555FF'>&gt;</font> <font color='#979000'>2</font><font face='Lucida Console'>)</font>
            <font color='#0000FF'>return</font> <font color='#979000'>false</font>;

        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>dims <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>2</font><font face='Lucida Console'>)</font> <b>{</b> <font color='#009900'>// Matrix type: require exact match (or dynamic)
</font>
            EigenIndex
                np_rows <font color='#5555FF'>=</font> a.<font color='#BB00BB'>shape</font><font face='Lucida Console'>(</font><font color='#979000'>0</font><font face='Lucida Console'>)</font>,
                np_cols <font color='#5555FF'>=</font> a.<font color='#BB00BB'>shape</font><font face='Lucida Console'>(</font><font color='#979000'>1</font><font face='Lucida Console'>)</font>,
                np_rstride <font color='#5555FF'>=</font> a.<font color='#BB00BB'>strides</font><font face='Lucida Console'>(</font><font color='#979000'>0</font><font face='Lucida Console'>)</font> <font color='#5555FF'>/</font> <font color='#0000FF'>static_cast</font><font color='#5555FF'>&lt;</font>ssize_t<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font color='#0000FF'>sizeof</font><font face='Lucida Console'>(</font>Scalar<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>,
                np_cstride <font color='#5555FF'>=</font> a.<font color='#BB00BB'>strides</font><font face='Lucida Console'>(</font><font color='#979000'>1</font><font face='Lucida Console'>)</font> <font color='#5555FF'>/</font> <font color='#0000FF'>static_cast</font><font color='#5555FF'>&lt;</font>ssize_t<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font color='#0000FF'>sizeof</font><font face='Lucida Console'>(</font>Scalar<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
            <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>fixed_rows <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> np_rows <font color='#5555FF'>!</font><font color='#5555FF'>=</font> rows<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> <font face='Lucida Console'>(</font>fixed_cols <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> np_cols <font color='#5555FF'>!</font><font color='#5555FF'>=</font> cols<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
                <font color='#0000FF'>return</font> <font color='#979000'>false</font>;

            <font color='#0000FF'>return</font> <b>{</b>np_rows, np_cols, np_rstride, np_cstride<b>}</b>;
        <b>}</b>

        <font color='#009900'>// Otherwise we're storing an n-vector.  Only one of the strides will be used, but whichever
</font>        <font color='#009900'>// is used, we want the (single) numpy stride value.
</font>        <font color='#0000FF'>const</font> EigenIndex n <font color='#5555FF'>=</font> a.<font color='#BB00BB'>shape</font><font face='Lucida Console'>(</font><font color='#979000'>0</font><font face='Lucida Console'>)</font>,
              stride <font color='#5555FF'>=</font> a.<font color='#BB00BB'>strides</font><font face='Lucida Console'>(</font><font color='#979000'>0</font><font face='Lucida Console'>)</font> <font color='#5555FF'>/</font> <font color='#0000FF'>static_cast</font><font color='#5555FF'>&lt;</font>ssize_t<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font color='#0000FF'>sizeof</font><font face='Lucida Console'>(</font>Scalar<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>vector<font face='Lucida Console'>)</font> <b>{</b> <font color='#009900'>// Eigen type is a compile-time vector
</font>            <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>fixed <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> size <font color='#5555FF'>!</font><font color='#5555FF'>=</font> n<font face='Lucida Console'>)</font>
                <font color='#0000FF'>return</font> <font color='#979000'>false</font>; <font color='#009900'>// Vector size mismatch
</font>            <font color='#0000FF'>return</font> <b>{</b>rows <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>1</font> ? <font color='#979000'>1</font> : n, cols <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>1</font> ? <font color='#979000'>1</font> : n, stride<b>}</b>;
        <b>}</b>
        <font color='#0000FF'>else</font> <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>fixed<font face='Lucida Console'>)</font> <b>{</b>
            <font color='#009900'>// The type has a fixed size, but is not a vector: abort
</font>            <font color='#0000FF'>return</font> <font color='#979000'>false</font>;
        <b>}</b>
        <font color='#0000FF'>else</font> <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>fixed_cols<font face='Lucida Console'>)</font> <b>{</b>
            <font color='#009900'>// Since this isn't a vector, cols must be != 1.  We allow this only if it exactly
</font>            <font color='#009900'>// equals the number of elements (rows is Dynamic, and so 1 row is allowed).
</font>            <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>cols <font color='#5555FF'>!</font><font color='#5555FF'>=</font> n<font face='Lucida Console'>)</font> <font color='#0000FF'>return</font> <font color='#979000'>false</font>;
            <font color='#0000FF'>return</font> <b>{</b><font color='#979000'>1</font>, n, stride<b>}</b>;
        <b>}</b>
        <font color='#0000FF'>else</font> <b>{</b>
            <font color='#009900'>// Otherwise it's either fully dynamic, or column dynamic; both become a column vector
</font>            <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>fixed_rows <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> rows <font color='#5555FF'>!</font><font color='#5555FF'>=</font> n<font face='Lucida Console'>)</font> <font color='#0000FF'>return</font> <font color='#979000'>false</font>;
            <font color='#0000FF'>return</font> <b>{</b>n, <font color='#979000'>1</font>, stride<b>}</b>;
        <b>}</b>
    <b>}</b>

    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'><u>bool</u></font> show_writeable <font color='#5555FF'>=</font> is_eigen_dense_map<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font>::value <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> is_eigen_mutable_map<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font>::value;
    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'><u>bool</u></font> show_order <font color='#5555FF'>=</font> is_eigen_dense_map<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font>::value;
    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'><u>bool</u></font> show_c_contiguous <font color='#5555FF'>=</font> show_order <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> requires_row_major;
    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'><u>bool</u></font> show_f_contiguous <font color='#5555FF'>=</font> <font color='#5555FF'>!</font>show_c_contiguous <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> show_order <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> requires_col_major;

    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'>auto</font> descriptor <font color='#5555FF'>=</font>
        <b><a name='_'></a>_</b><font face='Lucida Console'>(</font>"<font color='#CC0000'>numpy.ndarray[</font>"<font face='Lucida Console'>)</font> <font color='#5555FF'>+</font> npy_format_descriptor<font color='#5555FF'>&lt;</font>Scalar<font color='#5555FF'>&gt;</font>::name <font color='#5555FF'>+</font>
        <b><a name='_'></a>_</b><font face='Lucida Console'>(</font>"<font color='#CC0000'>[</font>"<font face='Lucida Console'>)</font>  <font color='#5555FF'>+</font> _<font color='#5555FF'>&lt;</font>fixed_rows<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>_<font color='#5555FF'>&lt;</font><font face='Lucida Console'>(</font><font color='#0000FF'><u>size_t</u></font><font face='Lucida Console'>)</font> rows<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, <font color='#BB00BB'>_</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>m</font>"<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>+</font>
        <b><a name='_'></a>_</b><font face='Lucida Console'>(</font>"<font color='#CC0000'>, </font>"<font face='Lucida Console'>)</font> <font color='#5555FF'>+</font> _<font color='#5555FF'>&lt;</font>fixed_cols<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>_<font color='#5555FF'>&lt;</font><font face='Lucida Console'>(</font><font color='#0000FF'><u>size_t</u></font><font face='Lucida Console'>)</font> cols<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, <font color='#BB00BB'>_</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>n</font>"<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>+</font>
        <b><a name='_'></a>_</b><font face='Lucida Console'>(</font>"<font color='#CC0000'>]</font>"<font face='Lucida Console'>)</font> <font color='#5555FF'>+</font>
        <font color='#009900'>// For a reference type (e.g. Ref&lt;MatrixXd&gt;) we have other constraints that might need to be
</font>        <font color='#009900'>// satisfied: writeable=True (for a mutable reference), and, depending on the map's stride
</font>        <font color='#009900'>// options, possibly f_contiguous or c_contiguous.  We include them in the descriptor output
</font>        <font color='#009900'>// to provide some hint as to why a TypeError is occurring (otherwise it can be confusing to
</font>        <font color='#009900'>// see that a function accepts a 'numpy.ndarray[float64[3,2]]' and an error message that you
</font>        <font color='#009900'>// *gave* a numpy.ndarray of the right type and dimensions.
</font>        _<font color='#5555FF'>&lt;</font>show_writeable<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>, flags.writeable</font>", "<font color='#CC0000'></font>"<font face='Lucida Console'>)</font> <font color='#5555FF'>+</font>
        _<font color='#5555FF'>&lt;</font>show_c_contiguous<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>, flags.c_contiguous</font>", "<font color='#CC0000'></font>"<font face='Lucida Console'>)</font> <font color='#5555FF'>+</font>
        _<font color='#5555FF'>&lt;</font>show_f_contiguous<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>, flags.f_contiguous</font>", "<font color='#CC0000'></font>"<font face='Lucida Console'>)</font> <font color='#5555FF'>+</font>
        <b><a name='_'></a>_</b><font face='Lucida Console'>(</font>"<font color='#CC0000'>]</font>"<font face='Lucida Console'>)</font>;
<b>}</b>;

<font color='#009900'>// Casts an Eigen type to numpy array.  If given a base, the numpy array references the src data,
</font><font color='#009900'>// otherwise it'll make a copy.  writeable lets you turn off the writeable flag for the array.
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> props<font color='#5555FF'>&gt;</font> handle <b><a name='eigen_array_cast'></a>eigen_array_cast</b><font face='Lucida Console'>(</font><font color='#0000FF'>typename</font> props::Type <font color='#0000FF'>const</font> <font color='#5555FF'>&amp;</font>src, handle base <font color='#5555FF'>=</font> <font color='#BB00BB'>handle</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, <font color='#0000FF'><u>bool</u></font> writeable <font color='#5555FF'>=</font> <font color='#979000'>true</font><font face='Lucida Console'>)</font> <b>{</b>
    constexpr ssize_t elem_size <font color='#5555FF'>=</font> <font color='#0000FF'>sizeof</font><font face='Lucida Console'>(</font><font color='#0000FF'>typename</font> props::Scalar<font face='Lucida Console'>)</font>;
    array a;
    <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>props::vector<font face='Lucida Console'>)</font>
        a <font color='#5555FF'>=</font> <font color='#BB00BB'>array</font><font face='Lucida Console'>(</font><b>{</b> src.<font color='#BB00BB'>size</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>}</b>, <b>{</b> elem_size <font color='#5555FF'>*</font> src.<font color='#BB00BB'>innerStride</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>}</b>, src.<font color='#BB00BB'>data</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, base<font face='Lucida Console'>)</font>;
    <font color='#0000FF'>else</font>
        a <font color='#5555FF'>=</font> <font color='#BB00BB'>array</font><font face='Lucida Console'>(</font><b>{</b> src.<font color='#BB00BB'>rows</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, src.<font color='#BB00BB'>cols</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>}</b>, <b>{</b> elem_size <font color='#5555FF'>*</font> src.<font color='#BB00BB'>rowStride</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, elem_size <font color='#5555FF'>*</font> src.<font color='#BB00BB'>colStride</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>}</b>,
                  src.<font color='#BB00BB'>data</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, base<font face='Lucida Console'>)</font>;

    <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font color='#5555FF'>!</font>writeable<font face='Lucida Console'>)</font>
        <font color='#BB00BB'>array_proxy</font><font face='Lucida Console'>(</font>a.<font color='#BB00BB'>ptr</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>-</font><font color='#5555FF'>&gt;</font>flags <font color='#5555FF'>&amp;</font><font color='#5555FF'>=</font> ~detail::npy_api::NPY_ARRAY_WRITEABLE_;

    <font color='#0000FF'>return</font> a.<font color='#BB00BB'>release</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
<b>}</b>

<font color='#009900'>// Takes an lvalue ref to some Eigen type and a (python) base object, creating a numpy array that
</font><font color='#009900'>// reference the Eigen object's data with `base` as the python-registered base class (if omitted,
</font><font color='#009900'>// the base will be set to None, and lifetime management is up to the caller).  The numpy array is
</font><font color='#009900'>// non-writeable if the given type is const.
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> props, <font color='#0000FF'>typename</font> Type<font color='#5555FF'>&gt;</font>
handle <b><a name='eigen_ref_array'></a>eigen_ref_array</b><font face='Lucida Console'>(</font>Type <font color='#5555FF'>&amp;</font>src, handle parent <font color='#5555FF'>=</font> <font color='#BB00BB'>none</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <b>{</b>
    <font color='#009900'>// none here is to get past array's should-we-copy detection, which currently always
</font>    <font color='#009900'>// copies when there is no base.  Setting the base to None should be harmless.
</font>    <font color='#0000FF'>return</font> eigen_array_cast<font color='#5555FF'>&lt;</font>props<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>src, parent, <font color='#5555FF'>!</font>std::is_const<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font>::value<font face='Lucida Console'>)</font>;
<b>}</b>

<font color='#009900'>// Takes a pointer to some dense, plain Eigen type, builds a capsule around it, then returns a numpy
</font><font color='#009900'>// array that references the encapsulated data with a python-side reference to the capsule to tie
</font><font color='#009900'>// its destruction to that of any dependent python objects.  Const-ness is determined by whether or
</font><font color='#009900'>// not the Type of the pointer given is const.
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> props, <font color='#0000FF'>typename</font> Type, <font color='#0000FF'>typename</font> <font color='#5555FF'>=</font> enable_if_t<font color='#5555FF'>&lt;</font>is_eigen_dense_plain<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>
handle <b><a name='eigen_encapsulate'></a>eigen_encapsulate</b><font face='Lucida Console'>(</font>Type <font color='#5555FF'>*</font>src<font face='Lucida Console'>)</font> <b>{</b>
    capsule <font color='#BB00BB'>base</font><font face='Lucida Console'>(</font>src, []<font face='Lucida Console'>(</font><font color='#0000FF'><u>void</u></font> <font color='#5555FF'>*</font>o<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>delete</font> <font color='#0000FF'>static_cast</font><font color='#5555FF'>&lt;</font>Type <font color='#5555FF'>*</font><font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font>; <b>}</b><font face='Lucida Console'>)</font>;
    <font color='#0000FF'>return</font> eigen_ref_array<font color='#5555FF'>&lt;</font>props<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font color='#5555FF'>*</font>src, base<font face='Lucida Console'>)</font>;
<b>}</b>

<font color='#009900'>// Type caster for regular, dense matrix types (e.g. MatrixXd), but not maps/refs/etc. of dense
</font><font color='#009900'>// types.
</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> Type<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='type_caster'></a>type_caster</b><font color='#5555FF'>&lt;</font>Type, enable_if_t<font color='#5555FF'>&lt;</font>is_eigen_dense_plain<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <b>{</b>
    <font color='#0000FF'>using</font> Scalar <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> Type::Scalar;
    <font color='#0000FF'>using</font> props <font color='#5555FF'>=</font> EigenProps<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font>;

    <font color='#0000FF'><u>bool</u></font> <b><a name='load'></a>load</b><font face='Lucida Console'>(</font>handle src, <font color='#0000FF'><u>bool</u></font> convert<font face='Lucida Console'>)</font> <b>{</b>
        <font color='#009900'>// If we're in no-convert mode, only load if given an array of the correct type
</font>        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font color='#5555FF'>!</font>convert <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> <font color='#5555FF'>!</font>isinstance<font color='#5555FF'>&lt;</font>array_t<font color='#5555FF'>&lt;</font>Scalar<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>src<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
            <font color='#0000FF'>return</font> <font color='#979000'>false</font>;

        <font color='#009900'>// Coerce into an array, but don't do type conversion yet; the copy below handles it.
</font>        <font color='#0000FF'>auto</font> buf <font color='#5555FF'>=</font> array::<font color='#BB00BB'>ensure</font><font face='Lucida Console'>(</font>src<font face='Lucida Console'>)</font>;

        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font color='#5555FF'>!</font>buf<font face='Lucida Console'>)</font>
            <font color='#0000FF'>return</font> <font color='#979000'>false</font>;

        <font color='#0000FF'>auto</font> dims <font color='#5555FF'>=</font> buf.<font color='#BB00BB'>ndim</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>dims <font color='#5555FF'>&lt;</font> <font color='#979000'>1</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> dims <font color='#5555FF'>&gt;</font> <font color='#979000'>2</font><font face='Lucida Console'>)</font>
            <font color='#0000FF'>return</font> <font color='#979000'>false</font>;

        <font color='#0000FF'>auto</font> fits <font color='#5555FF'>=</font> props::<font color='#BB00BB'>conformable</font><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font color='#5555FF'>!</font>fits<font face='Lucida Console'>)</font>
            <font color='#0000FF'>return</font> <font color='#979000'>false</font>;

        <font color='#009900'>// Allocate the new type, then build a numpy reference into it
</font>        value <font color='#5555FF'>=</font> <font color='#BB00BB'>Type</font><font face='Lucida Console'>(</font>fits.rows, fits.cols<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>auto</font> ref <font color='#5555FF'>=</font> reinterpret_steal<font color='#5555FF'>&lt;</font>array<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>eigen_ref_array<font color='#5555FF'>&lt;</font>props<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>value<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>dims <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>1</font><font face='Lucida Console'>)</font> ref <font color='#5555FF'>=</font> ref.<font color='#BB00BB'>squeeze</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#0000FF'>else</font> <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>ref.<font color='#BB00BB'>ndim</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>1</font><font face='Lucida Console'>)</font> buf <font color='#5555FF'>=</font> buf.<font color='#BB00BB'>squeeze</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;

        <font color='#0000FF'><u>int</u></font> result <font color='#5555FF'>=</font> detail::npy_api::<font color='#BB00BB'>get</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>.<font color='#BB00BB'>PyArray_CopyInto_</font><font face='Lucida Console'>(</font>ref.<font color='#BB00BB'>ptr</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, buf.<font color='#BB00BB'>ptr</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>result <font color='#5555FF'>&lt;</font> <font color='#979000'>0</font><font face='Lucida Console'>)</font> <b>{</b> <font color='#009900'>// Copy failed!
</font>            <font color='#BB00BB'>PyErr_Clear</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
            <font color='#0000FF'>return</font> <font color='#979000'>false</font>;
        <b>}</b>

        <font color='#0000FF'>return</font> <font color='#979000'>true</font>;
    <b>}</b>

<font color='#0000FF'>private</font>:

    <font color='#009900'>// Cast implementation
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> CType<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>static</font> handle <b><a name='cast_impl'></a>cast_impl</b><font face='Lucida Console'>(</font>CType <font color='#5555FF'>*</font>src, return_value_policy policy, handle parent<font face='Lucida Console'>)</font> <b>{</b>
        <font color='#0000FF'>switch</font> <font face='Lucida Console'>(</font>policy<font face='Lucida Console'>)</font> <b>{</b>
            <font color='#0000FF'>case</font> return_value_policy::take_ownership:
            <font color='#0000FF'>case</font> return_value_policy::automatic:
                <font color='#0000FF'>return</font> eigen_encapsulate<font color='#5555FF'>&lt;</font>props<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>src<font face='Lucida Console'>)</font>;
            <font color='#0000FF'>case</font> return_value_policy::move:
                <font color='#0000FF'>return</font> eigen_encapsulate<font color='#5555FF'>&lt;</font>props<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font color='#0000FF'>new</font> <font color='#BB00BB'>CType</font><font face='Lucida Console'>(</font>std::<font color='#BB00BB'>move</font><font face='Lucida Console'>(</font><font color='#5555FF'>*</font>src<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
            <font color='#0000FF'>case</font> return_value_policy::copy:
                <font color='#0000FF'>return</font> eigen_array_cast<font color='#5555FF'>&lt;</font>props<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font color='#5555FF'>*</font>src<font face='Lucida Console'>)</font>;
            <font color='#0000FF'>case</font> return_value_policy::reference:
            <font color='#0000FF'>case</font> return_value_policy::automatic_reference:
                <font color='#0000FF'>return</font> eigen_ref_array<font color='#5555FF'>&lt;</font>props<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font color='#5555FF'>*</font>src<font face='Lucida Console'>)</font>;
            <font color='#0000FF'>case</font> return_value_policy::reference_internal:
                <font color='#0000FF'>return</font> eigen_ref_array<font color='#5555FF'>&lt;</font>props<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font color='#5555FF'>*</font>src, parent<font face='Lucida Console'>)</font>;
            <font color='#0000FF'>default</font>:
                <font color='#0000FF'>throw</font> <font color='#BB00BB'>cast_error</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>unhandled return_value_policy: should not happen!</font>"<font face='Lucida Console'>)</font>;
        <b>}</b>;
    <b>}</b>

<font color='#0000FF'>public</font>:

    <font color='#009900'>// Normal returned non-reference, non-const value:
</font>    <font color='#0000FF'>static</font> handle <b><a name='cast'></a>cast</b><font face='Lucida Console'>(</font>Type <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font>src, return_value_policy <font color='#009900'>/* policy */</font>, handle parent<font face='Lucida Console'>)</font> <b>{</b>
        <font color='#0000FF'>return</font> <font color='#BB00BB'>cast_impl</font><font face='Lucida Console'>(</font><font color='#5555FF'>&amp;</font>src, return_value_policy::move, parent<font face='Lucida Console'>)</font>;
    <b>}</b>
    <font color='#009900'>// If you return a non-reference const, we mark the numpy array readonly:
</font>    <font color='#0000FF'>static</font> handle <b><a name='cast'></a>cast</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> Type <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font>src, return_value_policy <font color='#009900'>/* policy */</font>, handle parent<font face='Lucida Console'>)</font> <b>{</b>
        <font color='#0000FF'>return</font> <font color='#BB00BB'>cast_impl</font><font face='Lucida Console'>(</font><font color='#5555FF'>&amp;</font>src, return_value_policy::move, parent<font face='Lucida Console'>)</font>;
    <b>}</b>
    <font color='#009900'>// lvalue reference return; default (automatic) becomes copy
</font>    <font color='#0000FF'>static</font> handle <b><a name='cast'></a>cast</b><font face='Lucida Console'>(</font>Type <font color='#5555FF'>&amp;</font>src, return_value_policy policy, handle parent<font face='Lucida Console'>)</font> <b>{</b>
        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>policy <font color='#5555FF'>=</font><font color='#5555FF'>=</font> return_value_policy::automatic <font color='#5555FF'>|</font><font color='#5555FF'>|</font> policy <font color='#5555FF'>=</font><font color='#5555FF'>=</font> return_value_policy::automatic_reference<font face='Lucida Console'>)</font>
            policy <font color='#5555FF'>=</font> return_value_policy::copy;
        <font color='#0000FF'>return</font> <font color='#BB00BB'>cast_impl</font><font face='Lucida Console'>(</font><font color='#5555FF'>&amp;</font>src, policy, parent<font face='Lucida Console'>)</font>;
    <b>}</b>
    <font color='#009900'>// const lvalue reference return; default (automatic) becomes copy
</font>    <font color='#0000FF'>static</font> handle <b><a name='cast'></a>cast</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> Type <font color='#5555FF'>&amp;</font>src, return_value_policy policy, handle parent<font face='Lucida Console'>)</font> <b>{</b>
        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>policy <font color='#5555FF'>=</font><font color='#5555FF'>=</font> return_value_policy::automatic <font color='#5555FF'>|</font><font color='#5555FF'>|</font> policy <font color='#5555FF'>=</font><font color='#5555FF'>=</font> return_value_policy::automatic_reference<font face='Lucida Console'>)</font>
            policy <font color='#5555FF'>=</font> return_value_policy::copy;
        <font color='#0000FF'>return</font> <font color='#BB00BB'>cast</font><font face='Lucida Console'>(</font><font color='#5555FF'>&amp;</font>src, policy, parent<font face='Lucida Console'>)</font>;
    <b>}</b>
    <font color='#009900'>// non-const pointer return
</font>    <font color='#0000FF'>static</font> handle <b><a name='cast'></a>cast</b><font face='Lucida Console'>(</font>Type <font color='#5555FF'>*</font>src, return_value_policy policy, handle parent<font face='Lucida Console'>)</font> <b>{</b>
        <font color='#0000FF'>return</font> <font color='#BB00BB'>cast_impl</font><font face='Lucida Console'>(</font>src, policy, parent<font face='Lucida Console'>)</font>;
    <b>}</b>
    <font color='#009900'>// const pointer return
</font>    <font color='#0000FF'>static</font> handle <b><a name='cast'></a>cast</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> Type <font color='#5555FF'>*</font>src, return_value_policy policy, handle parent<font face='Lucida Console'>)</font> <b>{</b>
        <font color='#0000FF'>return</font> <font color='#BB00BB'>cast_impl</font><font face='Lucida Console'>(</font>src, policy, parent<font face='Lucida Console'>)</font>;
    <b>}</b>

    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'>auto</font> name <font color='#5555FF'>=</font> props::descriptor;

    <b><a name='operator'></a>operator</b> Type<font color='#5555FF'>*</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> <font color='#5555FF'>&amp;</font>value; <b>}</b>
    <b><a name='operator'></a>operator</b> Type<font color='#5555FF'>&amp;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> value; <b>}</b>
    <b><a name='operator'></a>operator</b> Type<font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> <b>{</b> <font color='#0000FF'>return</font> std::<font color='#BB00BB'>move</font><font face='Lucida Console'>(</font>value<font face='Lucida Console'>)</font>; <b>}</b>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> cast_op_type <font color='#5555FF'>=</font> movable_cast_op_type<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>;

<font color='#0000FF'>private</font>:
    Type value;
<b>}</b>;

<font color='#009900'>// Eigen Ref/Map classes have slightly different policy requirements, meaning we don't want to force
</font><font color='#009900'>// `move` when a Ref/Map rvalue is returned; we treat Ref&lt;&gt; sort of like a pointer (we care about
</font><font color='#009900'>// the underlying data, not the outer shell).
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> Return<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='return_value_policy_override'></a>return_value_policy_override</b><font color='#5555FF'>&lt;</font>Return, enable_if_t<font color='#5555FF'>&lt;</font>is_eigen_dense_map<font color='#5555FF'>&lt;</font>Return<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <b>{</b>
    <font color='#0000FF'>static</font> return_value_policy <b><a name='policy'></a>policy</b><font face='Lucida Console'>(</font>return_value_policy p<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> p; <b>}</b>
<b>}</b>;

<font color='#009900'>// Base class for casting reference/map/block/etc. objects back to python.
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> MapType<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='eigen_map_caster'></a>eigen_map_caster</b> <b>{</b>
<font color='#0000FF'>private</font>:
    <font color='#0000FF'>using</font> props <font color='#5555FF'>=</font> EigenProps<font color='#5555FF'>&lt;</font>MapType<font color='#5555FF'>&gt;</font>;

<font color='#0000FF'>public</font>:

    <font color='#009900'>// Directly referencing a ref/map's data is a bit dangerous (whatever the map/ref points to has
</font>    <font color='#009900'>// to stay around), but we'll allow it under the assumption that you know what you're doing (and
</font>    <font color='#009900'>// have an appropriate keep_alive in place).  We return a numpy array pointing directly at the
</font>    <font color='#009900'>// ref's data (The numpy array ends up read-only if the ref was to a const matrix type.) Note
</font>    <font color='#009900'>// that this means you need to ensure you don't destroy the object in some other way (e.g. with
</font>    <font color='#009900'>// an appropriate keep_alive, or with a reference to a statically allocated matrix).
</font>    <font color='#0000FF'>static</font> handle <b><a name='cast'></a>cast</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> MapType <font color='#5555FF'>&amp;</font>src, return_value_policy policy, handle parent<font face='Lucida Console'>)</font> <b>{</b>
        <font color='#0000FF'>switch</font> <font face='Lucida Console'>(</font>policy<font face='Lucida Console'>)</font> <b>{</b>
            <font color='#0000FF'>case</font> return_value_policy::copy:
                <font color='#0000FF'>return</font> eigen_array_cast<font color='#5555FF'>&lt;</font>props<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>src<font face='Lucida Console'>)</font>;
            <font color='#0000FF'>case</font> return_value_policy::reference_internal:
                <font color='#0000FF'>return</font> eigen_array_cast<font color='#5555FF'>&lt;</font>props<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>src, parent, is_eigen_mutable_map<font color='#5555FF'>&lt;</font>MapType<font color='#5555FF'>&gt;</font>::value<font face='Lucida Console'>)</font>;
            <font color='#0000FF'>case</font> return_value_policy::reference:
            <font color='#0000FF'>case</font> return_value_policy::automatic:
            <font color='#0000FF'>case</font> return_value_policy::automatic_reference:
                <font color='#0000FF'>return</font> eigen_array_cast<font color='#5555FF'>&lt;</font>props<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>src, <font color='#BB00BB'>none</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, is_eigen_mutable_map<font color='#5555FF'>&lt;</font>MapType<font color='#5555FF'>&gt;</font>::value<font face='Lucida Console'>)</font>;
            <font color='#0000FF'>default</font>:
                <font color='#009900'>// move, take_ownership don't make any sense for a ref/map:
</font>                <font color='#BB00BB'>pybind11_fail</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>Invalid return_value_policy for Eigen Map/Ref/Block type</font>"<font face='Lucida Console'>)</font>;
        <b>}</b>
    <b>}</b>

    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'>auto</font> name <font color='#5555FF'>=</font> props::descriptor;

    <font color='#009900'>// Explicitly delete these: support python -&gt; C++ conversion on these (i.e. these can be return
</font>    <font color='#009900'>// types but not bound arguments).  We still provide them (with an explicitly delete) so that
</font>    <font color='#009900'>// you end up here if you try anyway.
</font>    <font color='#0000FF'><u>bool</u></font> <b><a name='load'></a>load</b><font face='Lucida Console'>(</font>handle, <font color='#0000FF'><u>bool</u></font><font face='Lucida Console'>)</font> <font color='#5555FF'>=</font> <font color='#0000FF'>delete</font>;
    <b><a name='operator'></a>operator</b> <b><a name='MapType'></a>MapType</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#5555FF'>=</font> <font color='#0000FF'>delete</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> cast_op_type <font color='#5555FF'>=</font> MapType;
<b>}</b>;

<font color='#009900'>// We can return any map-like object (but can only load Refs, specialized next):
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> Type<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='type_caster'></a>type_caster</b><font color='#5555FF'>&lt;</font>Type, enable_if_t<font color='#5555FF'>&lt;</font>is_eigen_dense_map<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>
    : eigen_map_caster<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font> <b>{</b><b>}</b>;

<font color='#009900'>// Loader for Ref&lt;...&gt; arguments.  See the documentation for info on how to make this work without
</font><font color='#009900'>// copying (it requires some extra effort in many cases).
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> PlainObjectType, <font color='#0000FF'>typename</font> StrideType<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='type_caster'></a>type_caster</b><font color='#5555FF'>&lt;</font>
    Eigen::Ref<font color='#5555FF'>&lt;</font>PlainObjectType, <font color='#979000'>0</font>, StrideType<font color='#5555FF'>&gt;</font>,
    enable_if_t<font color='#5555FF'>&lt;</font>is_eigen_dense_map<font color='#5555FF'>&lt;</font>Eigen::Ref<font color='#5555FF'>&lt;</font>PlainObjectType, <font color='#979000'>0</font>, StrideType<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font>
<font color='#5555FF'>&gt;</font> : <font color='#0000FF'>public</font> eigen_map_caster<font color='#5555FF'>&lt;</font>Eigen::Ref<font color='#5555FF'>&lt;</font>PlainObjectType, <font color='#979000'>0</font>, StrideType<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <b>{</b>
<font color='#0000FF'>private</font>:
    <font color='#0000FF'>using</font> Type <font color='#5555FF'>=</font> Eigen::Ref<font color='#5555FF'>&lt;</font>PlainObjectType, <font color='#979000'>0</font>, StrideType<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> props <font color='#5555FF'>=</font> EigenProps<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> Scalar <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> props::Scalar;
    <font color='#0000FF'>using</font> MapType <font color='#5555FF'>=</font> Eigen::Map<font color='#5555FF'>&lt;</font>PlainObjectType, <font color='#979000'>0</font>, StrideType<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> Array <font color='#5555FF'>=</font> array_t<font color='#5555FF'>&lt;</font>Scalar, array::forcecast <font color='#5555FF'>|</font>
                <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>props::row_major ? props::inner_stride : props::outer_stride<font face='Lucida Console'>)</font> <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>1</font> ? array::c_style :
                 <font face='Lucida Console'>(</font>props::row_major ? props::outer_stride : props::inner_stride<font face='Lucida Console'>)</font> <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>1</font> ? array::f_style : <font color='#979000'>0</font><font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'><u>bool</u></font> need_writeable <font color='#5555FF'>=</font> is_eigen_mutable_map<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font>::value;
    <font color='#009900'>// Delay construction (these have no default constructor)
</font>    std::unique_ptr<font color='#5555FF'>&lt;</font>MapType<font color='#5555FF'>&gt;</font> map;
    std::unique_ptr<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font> ref;
    <font color='#009900'>// Our array.  When possible, this is just a numpy array pointing to the source data, but
</font>    <font color='#009900'>// sometimes we can't avoid copying (e.g. input is not a numpy array at all, has an incompatible
</font>    <font color='#009900'>// layout, or is an array of a type that needs to be converted).  Using a numpy temporary
</font>    <font color='#009900'>// (rather than an Eigen temporary) saves an extra copy when we need both type conversion and
</font>    <font color='#009900'>// storage order conversion.  (Note that we refuse to use this temporary copy when loading an
</font>    <font color='#009900'>// argument for a Ref&lt;M&gt; with M non-const, i.e. a read-write reference).
</font>    Array copy_or_ref;
<font color='#0000FF'>public</font>:
    <font color='#0000FF'><u>bool</u></font> <b><a name='load'></a>load</b><font face='Lucida Console'>(</font>handle src, <font color='#0000FF'><u>bool</u></font> convert<font face='Lucida Console'>)</font> <b>{</b>
        <font color='#009900'>// First check whether what we have is already an array of the right type.  If not, we can't
</font>        <font color='#009900'>// avoid a copy (because the copy is also going to do type conversion).
</font>        <font color='#0000FF'><u>bool</u></font> need_copy <font color='#5555FF'>=</font> <font color='#5555FF'>!</font>isinstance<font color='#5555FF'>&lt;</font>Array<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>src<font face='Lucida Console'>)</font>;

        EigenConformable<font color='#5555FF'>&lt;</font>props::row_major<font color='#5555FF'>&gt;</font> fits;
        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font color='#5555FF'>!</font>need_copy<font face='Lucida Console'>)</font> <b>{</b>
            <font color='#009900'>// We don't need a converting copy, but we also need to check whether the strides are
</font>            <font color='#009900'>// compatible with the Ref's stride requirements
</font>            Array aref <font color='#5555FF'>=</font> reinterpret_borrow<font color='#5555FF'>&lt;</font>Array<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>src<font face='Lucida Console'>)</font>;

            <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>aref <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> <font face='Lucida Console'>(</font><font color='#5555FF'>!</font>need_writeable <font color='#5555FF'>|</font><font color='#5555FF'>|</font> aref.<font color='#BB00BB'>writeable</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <b>{</b>
                fits <font color='#5555FF'>=</font> props::<font color='#BB00BB'>conformable</font><font face='Lucida Console'>(</font>aref<font face='Lucida Console'>)</font>;
                <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font color='#5555FF'>!</font>fits<font face='Lucida Console'>)</font> <font color='#0000FF'>return</font> <font color='#979000'>false</font>; <font color='#009900'>// Incompatible dimensions
</font>                <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font color='#5555FF'>!</font>fits.<font color='#0000FF'>template</font> stride_compatible<font color='#5555FF'>&lt;</font>props<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
                    need_copy <font color='#5555FF'>=</font> <font color='#979000'>true</font>;
                <font color='#0000FF'>else</font>
                    copy_or_ref <font color='#5555FF'>=</font> std::<font color='#BB00BB'>move</font><font face='Lucida Console'>(</font>aref<font face='Lucida Console'>)</font>;
            <b>}</b>
            <font color='#0000FF'>else</font> <b>{</b>
                need_copy <font color='#5555FF'>=</font> <font color='#979000'>true</font>;
            <b>}</b>
        <b>}</b>

        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>need_copy<font face='Lucida Console'>)</font> <b>{</b>
            <font color='#009900'>// We need to copy: If we need a mutable reference, or we're not supposed to convert
</font>            <font color='#009900'>// (either because we're in the no-convert overload pass, or because we're explicitly
</font>            <font color='#009900'>// instructed not to copy (via `py::arg().noconvert()`) we have to fail loading.
</font>            <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font color='#5555FF'>!</font>convert <font color='#5555FF'>|</font><font color='#5555FF'>|</font> need_writeable<font face='Lucida Console'>)</font> <font color='#0000FF'>return</font> <font color='#979000'>false</font>;

            Array copy <font color='#5555FF'>=</font> Array::<font color='#BB00BB'>ensure</font><font face='Lucida Console'>(</font>src<font face='Lucida Console'>)</font>;
            <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font color='#5555FF'>!</font>copy<font face='Lucida Console'>)</font> <font color='#0000FF'>return</font> <font color='#979000'>false</font>;
            fits <font color='#5555FF'>=</font> props::<font color='#BB00BB'>conformable</font><font face='Lucida Console'>(</font>copy<font face='Lucida Console'>)</font>;
            <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font color='#5555FF'>!</font>fits <font color='#5555FF'>|</font><font color='#5555FF'>|</font> <font color='#5555FF'>!</font>fits.<font color='#0000FF'>template</font> stride_compatible<font color='#5555FF'>&lt;</font>props<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
                <font color='#0000FF'>return</font> <font color='#979000'>false</font>;
            copy_or_ref <font color='#5555FF'>=</font> std::<font color='#BB00BB'>move</font><font face='Lucida Console'>(</font>copy<font face='Lucida Console'>)</font>;
            loader_life_support::<font color='#BB00BB'>add_patient</font><font face='Lucida Console'>(</font>copy_or_ref<font face='Lucida Console'>)</font>;
        <b>}</b>

        ref.<font color='#BB00BB'>reset</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        map.<font color='#BB00BB'>reset</font><font face='Lucida Console'>(</font><font color='#0000FF'>new</font> <font color='#BB00BB'>MapType</font><font face='Lucida Console'>(</font><font color='#BB00BB'>data</font><font face='Lucida Console'>(</font>copy_or_ref<font face='Lucida Console'>)</font>, fits.rows, fits.cols, <font color='#BB00BB'>make_stride</font><font face='Lucida Console'>(</font>fits.stride.<font color='#BB00BB'>outer</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, fits.stride.<font color='#BB00BB'>inner</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
        ref.<font color='#BB00BB'>reset</font><font face='Lucida Console'>(</font><font color='#0000FF'>new</font> <font color='#BB00BB'>Type</font><font face='Lucida Console'>(</font><font color='#5555FF'>*</font>map<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

        <font color='#0000FF'>return</font> <font color='#979000'>true</font>;
    <b>}</b>

    <b><a name='operator'></a>operator</b> Type<font color='#5555FF'>*</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> ref.<font color='#BB00BB'>get</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; <b>}</b>
    <b><a name='operator'></a>operator</b> Type<font color='#5555FF'>&amp;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> <font color='#5555FF'>*</font>ref; <b>}</b>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> _T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> cast_op_type <font color='#5555FF'>=</font> pybind11::detail::cast_op_type<font color='#5555FF'>&lt;</font>_T<font color='#5555FF'>&gt;</font>;

<font color='#0000FF'>private</font>:
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T <font color='#5555FF'>=</font> Type, enable_if_t<font color='#5555FF'>&lt;</font>is_eigen_mutable_map<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::value, <font color='#0000FF'><u>int</u></font><font color='#5555FF'>&gt;</font> <font color='#5555FF'>=</font> <font color='#979000'>0</font><font color='#5555FF'>&gt;</font>
    Scalar <font color='#5555FF'>*</font><b><a name='data'></a>data</b><font face='Lucida Console'>(</font>Array <font color='#5555FF'>&amp;</font>a<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> a.<font color='#BB00BB'>mutable_data</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; <b>}</b>

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T <font color='#5555FF'>=</font> Type, enable_if_t<font color='#5555FF'>&lt;</font><font color='#5555FF'>!</font>is_eigen_mutable_map<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::value, <font color='#0000FF'><u>int</u></font><font color='#5555FF'>&gt;</font> <font color='#5555FF'>=</font> <font color='#979000'>0</font><font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>const</font> Scalar <font color='#5555FF'>*</font><b><a name='data'></a>data</b><font face='Lucida Console'>(</font>Array <font color='#5555FF'>&amp;</font>a<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> a.<font color='#BB00BB'>data</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; <b>}</b>

    <font color='#009900'>// Attempt to figure out a constructor of `Stride` that will work.
</font>    <font color='#009900'>// If both strides are fixed, use a default constructor:
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> stride_ctor_default <font color='#5555FF'>=</font> bool_constant<font color='#5555FF'>&lt;</font>
        S::InnerStrideAtCompileTime <font color='#5555FF'>!</font><font color='#5555FF'>=</font> Eigen::Dynamic <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> S::OuterStrideAtCompileTime <font color='#5555FF'>!</font><font color='#5555FF'>=</font> Eigen::Dynamic <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font>
        std::is_default_constructible<font color='#5555FF'>&lt;</font>S<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font>;
    <font color='#009900'>// Otherwise, if there is a two-index constructor, assume it is (outer,inner) like
</font>    <font color='#009900'>// Eigen::Stride, and use it:
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> stride_ctor_dual <font color='#5555FF'>=</font> bool_constant<font color='#5555FF'>&lt;</font>
        <font color='#5555FF'>!</font>stride_ctor_default<font color='#5555FF'>&lt;</font>S<font color='#5555FF'>&gt;</font>::value <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> std::is_constructible<font color='#5555FF'>&lt;</font>S, EigenIndex, EigenIndex<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font>;
    <font color='#009900'>// Otherwise, if there is a one-index constructor, and just one of the strides is dynamic, use
</font>    <font color='#009900'>// it (passing whichever stride is dynamic).
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> stride_ctor_outer <font color='#5555FF'>=</font> bool_constant<font color='#5555FF'>&lt;</font>
        <font color='#5555FF'>!</font>any_of<font color='#5555FF'>&lt;</font>stride_ctor_default<font color='#5555FF'>&lt;</font>S<font color='#5555FF'>&gt;</font>, stride_ctor_dual<font color='#5555FF'>&lt;</font>S<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>::value <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font>
        S::OuterStrideAtCompileTime <font color='#5555FF'>=</font><font color='#5555FF'>=</font> Eigen::Dynamic <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> S::InnerStrideAtCompileTime <font color='#5555FF'>!</font><font color='#5555FF'>=</font> Eigen::Dynamic <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font>
        std::is_constructible<font color='#5555FF'>&lt;</font>S, EigenIndex<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> stride_ctor_inner <font color='#5555FF'>=</font> bool_constant<font color='#5555FF'>&lt;</font>
        <font color='#5555FF'>!</font>any_of<font color='#5555FF'>&lt;</font>stride_ctor_default<font color='#5555FF'>&lt;</font>S<font color='#5555FF'>&gt;</font>, stride_ctor_dual<font color='#5555FF'>&lt;</font>S<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>::value <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font>
        S::InnerStrideAtCompileTime <font color='#5555FF'>=</font><font color='#5555FF'>=</font> Eigen::Dynamic <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> S::OuterStrideAtCompileTime <font color='#5555FF'>!</font><font color='#5555FF'>=</font> Eigen::Dynamic <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font>
        std::is_constructible<font color='#5555FF'>&lt;</font>S, EigenIndex<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S <font color='#5555FF'>=</font> StrideType, enable_if_t<font color='#5555FF'>&lt;</font>stride_ctor_default<font color='#5555FF'>&lt;</font>S<font color='#5555FF'>&gt;</font>::value, <font color='#0000FF'><u>int</u></font><font color='#5555FF'>&gt;</font> <font color='#5555FF'>=</font> <font color='#979000'>0</font><font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>static</font> S <b><a name='make_stride'></a>make_stride</b><font face='Lucida Console'>(</font>EigenIndex, EigenIndex<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> <font color='#BB00BB'>S</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; <b>}</b>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S <font color='#5555FF'>=</font> StrideType, enable_if_t<font color='#5555FF'>&lt;</font>stride_ctor_dual<font color='#5555FF'>&lt;</font>S<font color='#5555FF'>&gt;</font>::value, <font color='#0000FF'><u>int</u></font><font color='#5555FF'>&gt;</font> <font color='#5555FF'>=</font> <font color='#979000'>0</font><font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>static</font> S <b><a name='make_stride'></a>make_stride</b><font face='Lucida Console'>(</font>EigenIndex outer, EigenIndex inner<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> <font color='#BB00BB'>S</font><font face='Lucida Console'>(</font>outer, inner<font face='Lucida Console'>)</font>; <b>}</b>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S <font color='#5555FF'>=</font> StrideType, enable_if_t<font color='#5555FF'>&lt;</font>stride_ctor_outer<font color='#5555FF'>&lt;</font>S<font color='#5555FF'>&gt;</font>::value, <font color='#0000FF'><u>int</u></font><font color='#5555FF'>&gt;</font> <font color='#5555FF'>=</font> <font color='#979000'>0</font><font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>static</font> S <b><a name='make_stride'></a>make_stride</b><font face='Lucida Console'>(</font>EigenIndex outer, EigenIndex<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> <font color='#BB00BB'>S</font><font face='Lucida Console'>(</font>outer<font face='Lucida Console'>)</font>; <b>}</b>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> S <font color='#5555FF'>=</font> StrideType, enable_if_t<font color='#5555FF'>&lt;</font>stride_ctor_inner<font color='#5555FF'>&lt;</font>S<font color='#5555FF'>&gt;</font>::value, <font color='#0000FF'><u>int</u></font><font color='#5555FF'>&gt;</font> <font color='#5555FF'>=</font> <font color='#979000'>0</font><font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>static</font> S <b><a name='make_stride'></a>make_stride</b><font face='Lucida Console'>(</font>EigenIndex, EigenIndex inner<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> <font color='#BB00BB'>S</font><font face='Lucida Console'>(</font>inner<font face='Lucida Console'>)</font>; <b>}</b>

<b>}</b>;

<font color='#009900'>// type_caster for special matrix types (e.g. DiagonalMatrix), which are EigenBase, but not
</font><font color='#009900'>// EigenDense (i.e. they don't have a data(), at least not with the usual matrix layout).
</font><font color='#009900'>// load() is not supported, but we can cast them into the python domain by first copying to a
</font><font color='#009900'>// regular Eigen::Matrix, then casting that.
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> Type<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='type_caster'></a>type_caster</b><font color='#5555FF'>&lt;</font>Type, enable_if_t<font color='#5555FF'>&lt;</font>is_eigen_other<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <b>{</b>
<font color='#0000FF'>protected</font>:
    <font color='#0000FF'>using</font> Matrix <font color='#5555FF'>=</font> Eigen::Matrix<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> Type::Scalar, Type::RowsAtCompileTime, Type::ColsAtCompileTime<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> props <font color='#5555FF'>=</font> EigenProps<font color='#5555FF'>&lt;</font>Matrix<font color='#5555FF'>&gt;</font>;
<font color='#0000FF'>public</font>:
    <font color='#0000FF'>static</font> handle <b><a name='cast'></a>cast</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> Type <font color='#5555FF'>&amp;</font>src, return_value_policy <font color='#009900'>/* policy */</font>, handle <font color='#009900'>/* parent */</font><font face='Lucida Console'>)</font> <b>{</b>
        handle h <font color='#5555FF'>=</font> eigen_encapsulate<font color='#5555FF'>&lt;</font>props<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font color='#0000FF'>new</font> <font color='#BB00BB'>Matrix</font><font face='Lucida Console'>(</font>src<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
        <font color='#0000FF'>return</font> h;
    <b>}</b>
    <font color='#0000FF'>static</font> handle <b><a name='cast'></a>cast</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> Type <font color='#5555FF'>*</font>src, return_value_policy policy, handle parent<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> <font color='#BB00BB'>cast</font><font face='Lucida Console'>(</font><font color='#5555FF'>*</font>src, policy, parent<font face='Lucida Console'>)</font>; <b>}</b>

    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'>auto</font> name <font color='#5555FF'>=</font> props::descriptor;

    <font color='#009900'>// Explicitly delete these: support python -&gt; C++ conversion on these (i.e. these can be return
</font>    <font color='#009900'>// types but not bound arguments).  We still provide them (with an explicitly delete) so that
</font>    <font color='#009900'>// you end up here if you try anyway.
</font>    <font color='#0000FF'><u>bool</u></font> <b><a name='load'></a>load</b><font face='Lucida Console'>(</font>handle, <font color='#0000FF'><u>bool</u></font><font face='Lucida Console'>)</font> <font color='#5555FF'>=</font> <font color='#0000FF'>delete</font>;
    <b><a name='operator'></a>operator</b> <b><a name='Type'></a>Type</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#5555FF'>=</font> <font color='#0000FF'>delete</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> cast_op_type <font color='#5555FF'>=</font> Type;
<b>}</b>;

<font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> Type<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='type_caster'></a>type_caster</b><font color='#5555FF'>&lt;</font>Type, enable_if_t<font color='#5555FF'>&lt;</font>is_eigen_sparse<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <b>{</b>
    <font color='#0000FF'>typedef</font> <font color='#0000FF'>typename</font> Type::Scalar Scalar;
    <font color='#0000FF'>typedef</font> remove_reference_t<font color='#5555FF'>&lt;</font><b><a name='decltype'></a>decltype</b><font face='Lucida Console'>(</font><font color='#5555FF'>*</font>std::declval<font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>.<font color='#BB00BB'>outerIndexPtr</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font> StorageIndex;
    <font color='#0000FF'>typedef</font> <font color='#0000FF'>typename</font> Type::Index Index;
    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'><u>bool</u></font> rowMajor <font color='#5555FF'>=</font> Type::IsRowMajor;

    <font color='#0000FF'><u>bool</u></font> <b><a name='load'></a>load</b><font face='Lucida Console'>(</font>handle src, <font color='#0000FF'><u>bool</u></font><font face='Lucida Console'>)</font> <b>{</b>
        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font color='#5555FF'>!</font>src<font face='Lucida Console'>)</font>
            <font color='#0000FF'>return</font> <font color='#979000'>false</font>;

        <font color='#0000FF'>auto</font> obj <font color='#5555FF'>=</font> reinterpret_borrow<font color='#5555FF'>&lt;</font>object<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>src<font face='Lucida Console'>)</font>;
        object sparse_module <font color='#5555FF'>=</font> module::<font color='#BB00BB'>import</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>scipy.sparse</font>"<font face='Lucida Console'>)</font>;
        object matrix_type <font color='#5555FF'>=</font> sparse_module.<font color='#BB00BB'>attr</font><font face='Lucida Console'>(</font>
            rowMajor ? "<font color='#CC0000'>csr_matrix</font>" : "<font color='#CC0000'>csc_matrix</font>"<font face='Lucida Console'>)</font>;

        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font color='#5555FF'>!</font>obj.<font color='#BB00BB'>get_type</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>.<font color='#BB00BB'>is</font><font face='Lucida Console'>(</font>matrix_type<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <b>{</b>
            <font color='#0000FF'>try</font> <b>{</b>
                obj <font color='#5555FF'>=</font> <font color='#BB00BB'>matrix_type</font><font face='Lucida Console'>(</font>obj<font face='Lucida Console'>)</font>;
            <b>}</b> <font color='#0000FF'>catch</font> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> error_already_set <font color='#5555FF'>&amp;</font><font face='Lucida Console'>)</font> <b>{</b>
                <font color='#0000FF'>return</font> <font color='#979000'>false</font>;
            <b>}</b>
        <b>}</b>

        <font color='#0000FF'>auto</font> values <font color='#5555FF'>=</font> array_t<font color='#5555FF'>&lt;</font>Scalar<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>object<font face='Lucida Console'>)</font> obj.<font color='#BB00BB'>attr</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>data</font>"<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
        <font color='#0000FF'>auto</font> innerIndices <font color='#5555FF'>=</font> array_t<font color='#5555FF'>&lt;</font>StorageIndex<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>object<font face='Lucida Console'>)</font> obj.<font color='#BB00BB'>attr</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>indices</font>"<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
        <font color='#0000FF'>auto</font> outerIndices <font color='#5555FF'>=</font> array_t<font color='#5555FF'>&lt;</font>StorageIndex<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>object<font face='Lucida Console'>)</font> obj.<font color='#BB00BB'>attr</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>indptr</font>"<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
        <font color='#0000FF'>auto</font> shape <font color='#5555FF'>=</font> pybind11::<font color='#BB00BB'>tuple</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>pybind11::object<font face='Lucida Console'>)</font> obj.<font color='#BB00BB'>attr</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>shape</font>"<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
        <font color='#0000FF'>auto</font> nnz <font color='#5555FF'>=</font> obj.<font color='#BB00BB'>attr</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>nnz</font>"<font face='Lucida Console'>)</font>.cast<font color='#5555FF'>&lt;</font>Index<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;

        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font color='#5555FF'>!</font>values <font color='#5555FF'>|</font><font color='#5555FF'>|</font> <font color='#5555FF'>!</font>innerIndices <font color='#5555FF'>|</font><font color='#5555FF'>|</font> <font color='#5555FF'>!</font>outerIndices<font face='Lucida Console'>)</font>
            <font color='#0000FF'>return</font> <font color='#979000'>false</font>;

        value <font color='#5555FF'>=</font> Eigen::MappedSparseMatrix<font color='#5555FF'>&lt;</font>Scalar, Type::Flags, StorageIndex<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>
            shape[<font color='#979000'>0</font>].cast<font color='#5555FF'>&lt;</font>Index<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, shape[<font color='#979000'>1</font>].cast<font color='#5555FF'>&lt;</font>Index<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, nnz,
            outerIndices.<font color='#BB00BB'>mutable_data</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, innerIndices.<font color='#BB00BB'>mutable_data</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, values.<font color='#BB00BB'>mutable_data</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

        <font color='#0000FF'>return</font> <font color='#979000'>true</font>;
    <b>}</b>

    <font color='#0000FF'>static</font> handle <b><a name='cast'></a>cast</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> Type <font color='#5555FF'>&amp;</font>src, return_value_policy <font color='#009900'>/* policy */</font>, handle <font color='#009900'>/* parent */</font><font face='Lucida Console'>)</font> <b>{</b>
        <font color='#0000FF'>const_cast</font><font color='#5555FF'>&lt;</font>Type<font color='#5555FF'>&amp;</font><font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>src<font face='Lucida Console'>)</font>.<font color='#BB00BB'>makeCompressed</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;

        object matrix_type <font color='#5555FF'>=</font> module::<font color='#BB00BB'>import</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>scipy.sparse</font>"<font face='Lucida Console'>)</font>.<font color='#BB00BB'>attr</font><font face='Lucida Console'>(</font>
            rowMajor ? "<font color='#CC0000'>csr_matrix</font>" : "<font color='#CC0000'>csc_matrix</font>"<font face='Lucida Console'>)</font>;

        array <font color='#BB00BB'>data</font><font face='Lucida Console'>(</font>src.<font color='#BB00BB'>nonZeros</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, src.<font color='#BB00BB'>valuePtr</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
        array <font color='#BB00BB'>outerIndices</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>rowMajor ? src.<font color='#BB00BB'>rows</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> : src.<font color='#BB00BB'>cols</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>+</font> <font color='#979000'>1</font>, src.<font color='#BB00BB'>outerIndexPtr</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
        array <font color='#BB00BB'>innerIndices</font><font face='Lucida Console'>(</font>src.<font color='#BB00BB'>nonZeros</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, src.<font color='#BB00BB'>innerIndexPtr</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

        <font color='#0000FF'>return</font> <font color='#BB00BB'>matrix_type</font><font face='Lucida Console'>(</font>
            std::<font color='#BB00BB'>make_tuple</font><font face='Lucida Console'>(</font>data, innerIndices, outerIndices<font face='Lucida Console'>)</font>,
            std::<font color='#BB00BB'>make_pair</font><font face='Lucida Console'>(</font>src.<font color='#BB00BB'>rows</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, src.<font color='#BB00BB'>cols</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
        <font face='Lucida Console'>)</font>.<font color='#BB00BB'>release</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
    <b>}</b>

    <b><a name='PYBIND11_TYPE_CASTER'></a>PYBIND11_TYPE_CASTER</b><font face='Lucida Console'>(</font>Type, _<font color='#5555FF'>&lt;</font><font face='Lucida Console'>(</font>Type::IsRowMajor<font face='Lucida Console'>)</font> <font color='#5555FF'>!</font><font color='#5555FF'>=</font> <font color='#979000'>0</font><font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>scipy.sparse.csr_matrix[</font>", "<font color='#CC0000'>scipy.sparse.csc_matrix[</font>"<font face='Lucida Console'>)</font>
            <font color='#5555FF'>+</font> npy_format_descriptor<font color='#5555FF'>&lt;</font>Scalar<font color='#5555FF'>&gt;</font>::name <font color='#5555FF'>+</font> <font color='#BB00BB'>_</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>]</font>"<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b>}</b>;

<b><a name='NAMESPACE_END'></a>NAMESPACE_END</b><font face='Lucida Console'>(</font>detail<font face='Lucida Console'>)</font>
<b><a name='NAMESPACE_END'></a>NAMESPACE_END</b><font face='Lucida Console'>(</font>PYBIND11_NAMESPACE<font face='Lucida Console'>)</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>__GNUG__<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> defined<font face='Lucida Console'>(</font>__clang__<font face='Lucida Console'>)</font>
#  pragma GCC diagnostic pop
<font color='#0000FF'>#elif</font> defined<font face='Lucida Console'>(</font>_MSC_VER<font face='Lucida Console'>)</font>
#  pragma <b><a name='warning'></a>warning</b><font face='Lucida Console'>(</font>pop<font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>

</pre></body></html>