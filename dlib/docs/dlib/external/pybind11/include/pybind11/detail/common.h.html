<html><!-- Created using the cpp_pretty_printer from the dlib C++ library.  See http://dlib.net for updates. --><head><title>dlib C++ Library - common.h</title></head><body bgcolor='white'><pre>
<font color='#009900'>/*
    pybind11/detail/common.h -- Basic macros

    Copyright (c) 2016 Wenzel Jakob &lt;wenzel.jakob@epfl.ch&gt;

    All rights reserved. Use of this source code is governed by a
    BSD-style license that can be found in the LICENSE file.
*/</font>

<font color='#0000FF'>#pragma</font> once

<font color='#0000FF'>#if</font> <font color='#5555FF'>!</font>defined<font face='Lucida Console'>(</font>NAMESPACE_BEGIN<font face='Lucida Console'>)</font>
#  define <b><a name='NAMESPACE_BEGIN'></a>NAMESPACE_BEGIN</b><font face='Lucida Console'>(</font>name<font face='Lucida Console'>)</font> <font color='#0000FF'>namespace</font> name <b>{</b>
<font color='#0000FF'>#endif</font>
<font color='#0000FF'>#if</font> <font color='#5555FF'>!</font>defined<font face='Lucida Console'>(</font>NAMESPACE_END<font face='Lucida Console'>)</font>
#  define <b><a name='NAMESPACE_END'></a>NAMESPACE_END</b><font face='Lucida Console'>(</font>name<font face='Lucida Console'>)</font> <b>}</b>
<font color='#0000FF'>#endif</font>

<font color='#009900'>// Robust support for some features and loading modules compiled against different pybind versions
</font><font color='#009900'>// requires forcing hidden visibility on pybind code, so we enforce this by setting the attribute on
</font><font color='#009900'>// the main `pybind11` namespace.
</font><font color='#0000FF'>#if</font> <font color='#5555FF'>!</font>defined<font face='Lucida Console'>(</font>PYBIND11_NAMESPACE<font face='Lucida Console'>)</font>
#  ifdef __GNUG__
#    define PYBIND11_NAMESPACE pybind11 <b><a name='__attribute__'></a>__attribute__</b><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#BB00BB'>visibility</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>hidden</font>"<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
#  <font color='#0000FF'>else</font>
#    define PYBIND11_NAMESPACE pybind11
#  endif
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> <font color='#5555FF'>!</font>defined<font face='Lucida Console'>(</font>_MSC_VER<font face='Lucida Console'>)</font> <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> <font color='#5555FF'>!</font>defined<font face='Lucida Console'>(</font>__INTEL_COMPILER<font face='Lucida Console'>)</font>
#  <font color='#0000FF'>if</font> __cplusplus <font color='#5555FF'>&gt;</font><font color='#5555FF'>=</font> <font color='#979000'>201402</font>L
#    define PYBIND11_CPP14
#    <font color='#0000FF'>if</font> __cplusplus <font color='#5555FF'>&gt;</font> <font color='#979000'>201402</font>L <font color='#009900'>/* Temporary: should be updated to &gt;= the final C++17 value once known */</font>
#      define PYBIND11_CPP17
#    endif
#  endif
<font color='#0000FF'>#elif</font> defined<font face='Lucida Console'>(</font>_MSC_VER<font face='Lucida Console'>)</font>
<font color='#009900'>// MSVC sets _MSVC_LANG rather than __cplusplus (supposedly until the standard is fully implemented)
</font>#  <font color='#0000FF'>if</font> _MSVC_LANG <font color='#5555FF'>&gt;</font><font color='#5555FF'>=</font> <font color='#979000'>201402</font>L
#    define PYBIND11_CPP14
#    <font color='#0000FF'>if</font> _MSVC_LANG <font color='#5555FF'>&gt;</font> <font color='#979000'>201402</font>L <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> _MSC_VER <font color='#5555FF'>&gt;</font><font color='#5555FF'>=</font> <font color='#979000'>1910</font>
#      define PYBIND11_CPP17
#    endif
#  endif
<font color='#0000FF'>#endif</font>

<font color='#009900'>// Compiler version assertions
</font><font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>__INTEL_COMPILER<font face='Lucida Console'>)</font>
#  <font color='#0000FF'>if</font> __INTEL_COMPILER <font color='#5555FF'>&lt;</font> <font color='#979000'>1500</font>
#    error pybind11 requires Intel C<font color='#5555FF'>+</font><font color='#5555FF'>+</font> compiler v15 or newer
#  endif
<font color='#0000FF'>#elif</font> defined<font face='Lucida Console'>(</font>__clang__<font face='Lucida Console'>)</font> <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> <font color='#5555FF'>!</font>defined<font face='Lucida Console'>(</font>__apple_build_version__<font face='Lucida Console'>)</font>
#  <font color='#0000FF'>if</font> __clang_major__ <font color='#5555FF'>&lt;</font> <font color='#979000'>3</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> <font face='Lucida Console'>(</font>__clang_major__ <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>3</font> <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> __clang_minor__ <font color='#5555FF'>&lt;</font> <font color='#979000'>3</font><font face='Lucida Console'>)</font>
#    error pybind11 requires clang <font color='#979000'>3.3</font> or newer
#  endif
<font color='#0000FF'>#elif</font> defined<font face='Lucida Console'>(</font>__clang__<font face='Lucida Console'>)</font>
<font color='#009900'>// Apple changes clang version macros to its Xcode version; the first Xcode release based on
</font><font color='#009900'>// (upstream) clang 3.3 was Xcode 5:
</font>#  <font color='#0000FF'>if</font> __clang_major__ <font color='#5555FF'>&lt;</font> <font color='#979000'>5</font>
#    error pybind11 requires Xcode<font color='#5555FF'>/</font>clang <font color='#979000'>5.0</font> or newer
#  endif
<font color='#0000FF'>#elif</font> defined<font face='Lucida Console'>(</font>__GNUG__<font face='Lucida Console'>)</font>
#  <font color='#0000FF'>if</font> __GNUC__ <font color='#5555FF'>&lt;</font> <font color='#979000'>4</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> <font face='Lucida Console'>(</font>__GNUC__ <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>4</font> <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> __GNUC_MINOR__ <font color='#5555FF'>&lt;</font> <font color='#979000'>8</font><font face='Lucida Console'>)</font>
#    error pybind11 requires gcc <font color='#979000'>4.8</font> or newer
#  endif
<font color='#0000FF'>#elif</font> defined<font face='Lucida Console'>(</font>_MSC_VER<font face='Lucida Console'>)</font>
<font color='#009900'>// Pybind hits various compiler bugs in 2015u2 and earlier, and also makes use of some stl features
</font><font color='#009900'>// (e.g. std::negation) added in 2015u3:
</font>#  <font color='#0000FF'>if</font> _MSC_FULL_VER <font color='#5555FF'>&lt;</font> <font color='#979000'>190024210</font>
#    error pybind11 requires MSVC <font color='#979000'>2015</font> update <font color='#979000'>3</font> or newer
#  endif
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> <font color='#5555FF'>!</font>defined<font face='Lucida Console'>(</font>PYBIND11_EXPORT<font face='Lucida Console'>)</font>
#  <font color='#0000FF'>if</font> <b><a name='defined'></a>defined</b><font face='Lucida Console'>(</font>WIN32<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> <b><a name='defined'></a>defined</b><font face='Lucida Console'>(</font>_WIN32<font face='Lucida Console'>)</font>
#    define PYBIND11_EXPORT <b><a name='__declspec'></a>__declspec</b><font face='Lucida Console'>(</font>dllexport<font face='Lucida Console'>)</font>
#  <font color='#0000FF'>else</font>
#    define PYBIND11_EXPORT <b><a name='__attribute__'></a>__attribute__</b> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#BB00BB'>visibility</font><font face='Lucida Console'>(</font>"<font color='#CC0000'>default</font>"<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
#  endif
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>_MSC_VER<font face='Lucida Console'>)</font>
#  define PYBIND11_NOINLINE <b><a name='__declspec'></a>__declspec</b><font face='Lucida Console'>(</font>noinline<font face='Lucida Console'>)</font>
<font color='#0000FF'>#else</font>
#  define PYBIND11_NOINLINE <b><a name='__attribute__'></a>__attribute__</b> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>noinline<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PYBIND11_CPP14<font face='Lucida Console'>)</font>
#  define <b><a name='PYBIND11_DEPRECATED'></a>PYBIND11_DEPRECATED</b><font face='Lucida Console'>(</font>reason<font face='Lucida Console'>)</font> [[<b><a name='deprecated'></a>deprecated</b><font face='Lucida Console'>(</font>reason<font face='Lucida Console'>)</font>]]
<font color='#0000FF'>#else</font>
#  define <b><a name='PYBIND11_DEPRECATED'></a>PYBIND11_DEPRECATED</b><font face='Lucida Console'>(</font>reason<font face='Lucida Console'>)</font> <b><a name='__attribute__'></a>__attribute__</b><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#BB00BB'>deprecated</font><font face='Lucida Console'>(</font>reason<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#define</font> PYBIND11_VERSION_MAJOR <font color='#979000'>2</font>
<font color='#0000FF'>#define</font> PYBIND11_VERSION_MINOR <font color='#979000'>3</font>
<font color='#0000FF'>#define</font> PYBIND11_VERSION_PATCH dev0

<font color='#009900'>/// Include Python header, disable linking to pythonX_d.lib on Windows in debug mode
</font><font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>_MSC_VER<font face='Lucida Console'>)</font>
#  <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>PY_MAJOR_VERSION <font color='#5555FF'>=</font><font color='#5555FF'>=</font> <font color='#979000'>3</font> <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> PY_MINOR_VERSION <font color='#5555FF'>&lt;</font> <font color='#979000'>4</font><font face='Lucida Console'>)</font>
#    define HAVE_ROUND <font color='#979000'>1</font>
#  endif
#  pragma <b><a name='warning'></a>warning</b><font face='Lucida Console'>(</font>push<font face='Lucida Console'>)</font>
#  pragma <b><a name='warning'></a>warning</b><font face='Lucida Console'>(</font>disable: <font color='#979000'>4510</font> <font color='#979000'>4610</font> <font color='#979000'>4512</font> <font color='#979000'>4005</font><font face='Lucida Console'>)</font>
#  <font color='#0000FF'>if</font> <b><a name='defined'></a>defined</b><font face='Lucida Console'>(</font>_DEBUG<font face='Lucida Console'>)</font>
#    define PYBIND11_DEBUG_MARKER
#    undef _DEBUG
#  endif
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>Python.h<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>frameobject.h<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>pythread.h<font color='#5555FF'>&gt;</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>_WIN32<font face='Lucida Console'>)</font> <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> <font face='Lucida Console'>(</font>defined<font face='Lucida Console'>(</font>min<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> defined<font face='Lucida Console'>(</font>max<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
#  error Macro clash with min and max <font color='#5555FF'>-</font><font color='#5555FF'>-</font> define NOMINMAX when compiling your program on Windows
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>isalnum<font face='Lucida Console'>)</font>
#  undef isalnum
#  undef isalpha
#  undef islower
#  undef isspace
#  undef isupper
#  undef tolower
#  undef toupper
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>_MSC_VER<font face='Lucida Console'>)</font>
#  <font color='#0000FF'>if</font> <b><a name='defined'></a>defined</b><font face='Lucida Console'>(</font>PYBIND11_DEBUG_MARKER<font face='Lucida Console'>)</font>
#    define _DEBUG
#    undef PYBIND11_DEBUG_MARKER
#  endif
#  pragma <b><a name='warning'></a>warning</b><font face='Lucida Console'>(</font>pop<font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>cstddef<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>cstring<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>forward_list<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>vector<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>string<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>stdexcept<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>unordered_set<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>unordered_map<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>memory<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>typeindex<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>type_traits<font color='#5555FF'>&gt;</font>

<font color='#0000FF'>#if</font> PY_MAJOR_VERSION <font color='#5555FF'>&gt;</font><font color='#5555FF'>=</font> <font color='#979000'>3</font> <font color='#009900'>/// Compatibility macros for various Python versions
</font><font color='#0000FF'>#define</font> PYBIND11_INSTANCE_METHOD_NEW<font face='Lucida Console'>(</font>ptr, class_<font face='Lucida Console'>)</font> PyInstanceMethod_New<font face='Lucida Console'>(</font>ptr<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PYBIND11_INSTANCE_METHOD_CHECK PyInstanceMethod_Check
<font color='#0000FF'>#define</font> PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyInstanceMethod_GET_FUNCTION
<font color='#0000FF'>#define</font> PYBIND11_BYTES_CHECK PyBytes_Check
<font color='#0000FF'>#define</font> PYBIND11_BYTES_FROM_STRING PyBytes_FromString
<font color='#0000FF'>#define</font> PYBIND11_BYTES_FROM_STRING_AND_SIZE PyBytes_FromStringAndSize
<font color='#0000FF'>#define</font> PYBIND11_BYTES_AS_STRING_AND_SIZE PyBytes_AsStringAndSize
<font color='#0000FF'>#define</font> PYBIND11_BYTES_AS_STRING PyBytes_AsString
<font color='#0000FF'>#define</font> PYBIND11_BYTES_SIZE PyBytes_Size
<font color='#0000FF'>#define</font> PYBIND11_LONG_CHECK<font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font> PyLong_Check<font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PYBIND11_LONG_AS_LONGLONG<font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font> PyLong_AsLongLong<font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PYBIND11_LONG_FROM_SIGNED<font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font> PyLong_FromSsize_t<font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>ssize_t<font face='Lucida Console'>)</font> o<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PYBIND11_LONG_FROM_UNSIGNED<font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font> PyLong_FromSize_t<font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#0000FF'><u>size_t</u></font><font face='Lucida Console'>)</font> o<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PYBIND11_BYTES_NAME "<font color='#CC0000'>bytes</font>"
<font color='#0000FF'>#define</font> PYBIND11_STRING_NAME "<font color='#CC0000'>str</font>"
<font color='#0000FF'>#define</font> PYBIND11_SLICE_OBJECT PyObject
<font color='#0000FF'>#define</font> PYBIND11_FROM_STRING PyUnicode_FromString
<font color='#0000FF'>#define</font> PYBIND11_STR_TYPE ::pybind11::str
<font color='#0000FF'>#define</font> PYBIND11_BOOL_ATTR "<font color='#CC0000'>__bool__</font>"
<font color='#0000FF'>#define</font> PYBIND11_NB_BOOL<font face='Lucida Console'>(</font>ptr<font face='Lucida Console'>)</font> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>ptr<font face='Lucida Console'>)</font><font color='#5555FF'>-</font><font color='#5555FF'>&gt;</font>nb_bool<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PYBIND11_PLUGIN_IMPL<font face='Lucida Console'>(</font>name<font face='Lucida Console'>)</font> \
    <font color='#0000FF'>extern</font> "<font color='#CC0000'>C</font>" PYBIND11_EXPORT PyObject <font color='#5555FF'>*</font>PyInit_##<b><a name='name'></a>name</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>

<font color='#0000FF'>#else</font>
<font color='#0000FF'>#define</font> PYBIND11_INSTANCE_METHOD_NEW<font face='Lucida Console'>(</font>ptr, class_<font face='Lucida Console'>)</font> PyMethod_New<font face='Lucida Console'>(</font>ptr, nullptr, class_<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PYBIND11_INSTANCE_METHOD_CHECK PyMethod_Check
<font color='#0000FF'>#define</font> PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyMethod_GET_FUNCTION
<font color='#0000FF'>#define</font> PYBIND11_BYTES_CHECK PyString_Check
<font color='#0000FF'>#define</font> PYBIND11_BYTES_FROM_STRING PyString_FromString
<font color='#0000FF'>#define</font> PYBIND11_BYTES_FROM_STRING_AND_SIZE PyString_FromStringAndSize
<font color='#0000FF'>#define</font> PYBIND11_BYTES_AS_STRING_AND_SIZE PyString_AsStringAndSize
<font color='#0000FF'>#define</font> PYBIND11_BYTES_AS_STRING PyString_AsString
<font color='#0000FF'>#define</font> PYBIND11_BYTES_SIZE PyString_Size
<font color='#0000FF'>#define</font> PYBIND11_LONG_CHECK<font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font> <font face='Lucida Console'>(</font>PyInt_Check<font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> PyLong_Check<font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PYBIND11_LONG_AS_LONGLONG<font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font> <font face='Lucida Console'>(</font>PyInt_Check<font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font> ? <font face='Lucida Console'>(</font><font color='#0000FF'><u>long</u></font> <font color='#0000FF'><u>long</u></font><font face='Lucida Console'>)</font> PyLong_AsLong<font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font> : PyLong_AsLongLong<font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PYBIND11_LONG_FROM_SIGNED<font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font> PyInt_FromSsize_t<font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>ssize_t<font face='Lucida Console'>)</font> o<font face='Lucida Console'>)</font> <font color='#009900'>// Returns long if needed.
</font><font color='#0000FF'>#define</font> PYBIND11_LONG_FROM_UNSIGNED<font face='Lucida Console'>(</font>o<font face='Lucida Console'>)</font> PyInt_FromSize_t<font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#0000FF'><u>size_t</u></font><font face='Lucida Console'>)</font> o<font face='Lucida Console'>)</font> <font color='#009900'>// Returns long if needed.
</font><font color='#0000FF'>#define</font> PYBIND11_BYTES_NAME "<font color='#CC0000'>str</font>"
<font color='#0000FF'>#define</font> PYBIND11_STRING_NAME "<font color='#CC0000'>unicode</font>"
<font color='#0000FF'>#define</font> PYBIND11_SLICE_OBJECT PySliceObject
<font color='#0000FF'>#define</font> PYBIND11_FROM_STRING PyString_FromString
<font color='#0000FF'>#define</font> PYBIND11_STR_TYPE ::pybind11::bytes
<font color='#0000FF'>#define</font> PYBIND11_BOOL_ATTR "<font color='#CC0000'>__nonzero__</font>"
<font color='#0000FF'>#define</font> PYBIND11_NB_BOOL<font face='Lucida Console'>(</font>ptr<font face='Lucida Console'>)</font> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>ptr<font face='Lucida Console'>)</font><font color='#5555FF'>-</font><font color='#5555FF'>&gt;</font>nb_nonzero<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PYBIND11_PLUGIN_IMPL<font face='Lucida Console'>(</font>name<font face='Lucida Console'>)</font> \
    <font color='#0000FF'>static</font> PyObject <font color='#5555FF'>*</font><b><a name='pybind11_init_wrapper'></a>pybind11_init_wrapper</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;               \
    <font color='#0000FF'>extern</font> "<font color='#CC0000'>C</font>" PYBIND11_EXPORT <font color='#0000FF'><u>void</u></font> init##<b><a name='name'></a>name</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>{</b>          \
        <font face='Lucida Console'>(</font><font color='#0000FF'><u>void</u></font><font face='Lucida Console'>)</font><b><a name='pybind11_init_wrapper'></a>pybind11_init_wrapper</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;                      \
    <b>}</b>                                                       \
    PyObject <font color='#5555FF'>*</font><b><a name='pybind11_init_wrapper'></a>pybind11_init_wrapper</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> PY_VERSION_HEX <font color='#5555FF'>&gt;</font><font color='#5555FF'>=</font> <font color='#979000'>0x03050000</font> <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> PY_VERSION_HEX <font color='#5555FF'>&lt;</font> <font color='#979000'>0x03050200</font>
<font color='#0000FF'>extern</font> "<font color='#CC0000'>C</font>" <b>{</b>
    <font color='#0000FF'>struct</font> <b><a name='_Py_atomic_address'></a>_Py_atomic_address</b> <b>{</b> <font color='#0000FF'><u>void</u></font> <font color='#5555FF'>*</font>value; <b>}</b>;
    <b><a name='PyAPI_DATA'></a>PyAPI_DATA</b><font face='Lucida Console'>(</font>_Py_atomic_address<font face='Lucida Console'>)</font> _PyThreadState_Current;
<b>}</b>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#define</font> PYBIND11_TRY_NEXT_OVERLOAD <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>PyObject <font color='#5555FF'>*</font><font face='Lucida Console'>)</font> <font color='#979000'>1</font><font face='Lucida Console'>)</font> <font color='#009900'>// special failure return code
</font><font color='#0000FF'>#define</font> PYBIND11_STRINGIFY<font face='Lucida Console'>(</font>x<font face='Lucida Console'>)</font> #x
<font color='#0000FF'>#define</font> PYBIND11_TOSTRING<font face='Lucida Console'>(</font>x<font face='Lucida Console'>)</font> PYBIND11_STRINGIFY<font face='Lucida Console'>(</font>x<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PYBIND11_CONCAT<font face='Lucida Console'>(</font>first, second<font face='Lucida Console'>)</font> first##second

<font color='#009900'>/** \rst
    ***Deprecated in favor of PYBIND11_MODULE***

    This macro creates the entry point that will be invoked when the Python interpreter
    imports a plugin library. Please create a `module` in the function body and return
    the pointer to its underlying Python object at the end.

    .. code-block:: cpp

        PYBIND11_PLUGIN(example) {
            pybind11::module m("example", "pybind11 example plugin");
            /// Set up bindings here
            return m.ptr();
        }
\endrst */</font>
<font color='#0000FF'>#define</font> PYBIND11_PLUGIN<font face='Lucida Console'>(</font>name<font face='Lucida Console'>)</font>                                                  \
    <b><a name='PYBIND11_DEPRECATED'></a>PYBIND11_DEPRECATED</b><font face='Lucida Console'>(</font>"<font color='#CC0000'>PYBIND11_PLUGIN is deprecated, use PYBIND11_MODULE</font>"<font face='Lucida Console'>)</font>  \
    <font color='#0000FF'>static</font> PyObject <font color='#5555FF'>*</font><b><a name='pybind11_init'></a>pybind11_init</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;                                          \
    <b><a name='PYBIND11_PLUGIN_IMPL'></a>PYBIND11_PLUGIN_IMPL</b><font face='Lucida Console'>(</font>name<font face='Lucida Console'>)</font> <b>{</b>                                               \
        <font color='#0000FF'><u>int</u></font> major, minor;                                                      \
        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font color='#BB00BB'>sscanf</font><font face='Lucida Console'>(</font><font color='#BB00BB'>Py_GetVersion</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, "<font color='#CC0000'>%i.%i</font>", <font color='#5555FF'>&amp;</font>major, <font color='#5555FF'>&amp;</font>minor<font face='Lucida Console'>)</font> <font color='#5555FF'>!</font><font color='#5555FF'>=</font> <font color='#979000'>2</font><font face='Lucida Console'>)</font> <b>{</b>           \
            <font color='#BB00BB'>PyErr_SetString</font><font face='Lucida Console'>(</font>PyExc_ImportError, "<font color='#CC0000'>Can't parse Python version.</font>"<font face='Lucida Console'>)</font>; \
            <font color='#0000FF'>return</font> nullptr;                                                    \
        <b>}</b> <font color='#0000FF'>else</font> <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>major <font color='#5555FF'>!</font><font color='#5555FF'>=</font> PY_MAJOR_VERSION <font color='#5555FF'>|</font><font color='#5555FF'>|</font> minor <font color='#5555FF'>!</font><font color='#5555FF'>=</font> PY_MINOR_VERSION<font face='Lucida Console'>)</font> <b>{</b>   \
            <font color='#BB00BB'>PyErr_Format</font><font face='Lucida Console'>(</font>PyExc_ImportError,                                    \
                         "<font color='#CC0000'>Python version mismatch: module was compiled for </font>"   \
                         "<font color='#CC0000'>version %i.%i, while the interpreter is running </font>"    \
                         "<font color='#CC0000'>version %i.%i.</font>", PY_MAJOR_VERSION, PY_MINOR_VERSION, \
                         major, minor<font face='Lucida Console'>)</font>;                                        \
            <font color='#0000FF'>return</font> nullptr;                                                    \
        <b>}</b>                                                                      \
        <font color='#0000FF'>try</font> <b>{</b>                                                                  \
            <font color='#0000FF'>return</font> <font color='#BB00BB'>pybind11_init</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;                                            \
        <b>}</b> <font color='#0000FF'>catch</font> <font face='Lucida Console'>(</font>pybind11::error_already_set <font color='#5555FF'>&amp;</font>e<font face='Lucida Console'>)</font> <b>{</b>                             \
            <font color='#BB00BB'>PyErr_SetString</font><font face='Lucida Console'>(</font>PyExc_ImportError, e.<font color='#BB00BB'>what</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;                      \
            <font color='#0000FF'>return</font> nullptr;                                                    \
        <b>}</b> <font color='#0000FF'>catch</font> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> std::exception <font color='#5555FF'>&amp;</font>e<font face='Lucida Console'>)</font> <b>{</b>                                    \
            <font color='#BB00BB'>PyErr_SetString</font><font face='Lucida Console'>(</font>PyExc_ImportError, e.<font color='#BB00BB'>what</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;                      \
            <font color='#0000FF'>return</font> nullptr;                                                    \
        <b>}</b>                                                                      \
    <b>}</b>                                                                          \
    PyObject <font color='#5555FF'>*</font><b><a name='pybind11_init'></a>pybind11_init</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>

<font color='#009900'>/** \rst
    This macro creates the entry point that will be invoked when the Python interpreter
    imports an extension module. The module name is given as the fist argument and it
    should not be in quotes. The second macro argument defines a variable of type
    `py::module` which can be used to initialize the module.

    .. code-block:: cpp

        PYBIND11_MODULE(example, m) {
            m.doc() = "pybind11 example module";

            // Add bindings here
            m.def("foo", []() {
                return "Hello, World!";
            });
        }
\endrst */</font>
<font color='#0000FF'>#define</font> PYBIND11_MODULE<font face='Lucida Console'>(</font>name, variable<font face='Lucida Console'>)</font>                                        \
    <font color='#0000FF'>static</font> <font color='#0000FF'><u>void</u></font> <b><a name='PYBIND11_CONCAT'></a>PYBIND11_CONCAT</b><font face='Lucida Console'>(</font>pybind11_init_, name<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>pybind11::module <font color='#5555FF'>&amp;</font><font face='Lucida Console'>)</font>;     \
    <b><a name='PYBIND11_PLUGIN_IMPL'></a>PYBIND11_PLUGIN_IMPL</b><font face='Lucida Console'>(</font>name<font face='Lucida Console'>)</font> <b>{</b>                                               \
        <font color='#0000FF'><u>int</u></font> major, minor;                                                      \
        <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font><font color='#BB00BB'>sscanf</font><font face='Lucida Console'>(</font><font color='#BB00BB'>Py_GetVersion</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, "<font color='#CC0000'>%i.%i</font>", <font color='#5555FF'>&amp;</font>major, <font color='#5555FF'>&amp;</font>minor<font face='Lucida Console'>)</font> <font color='#5555FF'>!</font><font color='#5555FF'>=</font> <font color='#979000'>2</font><font face='Lucida Console'>)</font> <b>{</b>           \
            <font color='#BB00BB'>PyErr_SetString</font><font face='Lucida Console'>(</font>PyExc_ImportError, "<font color='#CC0000'>Can't parse Python version.</font>"<font face='Lucida Console'>)</font>; \
            <font color='#0000FF'>return</font> nullptr;                                                    \
        <b>}</b> <font color='#0000FF'>else</font> <font color='#0000FF'>if</font> <font face='Lucida Console'>(</font>major <font color='#5555FF'>!</font><font color='#5555FF'>=</font> PY_MAJOR_VERSION <font color='#5555FF'>|</font><font color='#5555FF'>|</font> minor <font color='#5555FF'>!</font><font color='#5555FF'>=</font> PY_MINOR_VERSION<font face='Lucida Console'>)</font> <b>{</b>   \
            <font color='#BB00BB'>PyErr_Format</font><font face='Lucida Console'>(</font>PyExc_ImportError,                                    \
                         "<font color='#CC0000'>Python version mismatch: module was compiled for </font>"   \
                         "<font color='#CC0000'>version %i.%i, while the interpreter is running </font>"    \
                         "<font color='#CC0000'>version %i.%i.</font>", PY_MAJOR_VERSION, PY_MINOR_VERSION, \
                         major, minor<font face='Lucida Console'>)</font>;                                        \
            <font color='#0000FF'>return</font> nullptr;                                                    \
        <b>}</b>                                                                      \
        <font color='#0000FF'>auto</font> m <font color='#5555FF'>=</font> pybind11::<font color='#BB00BB'>module</font><font face='Lucida Console'>(</font><font color='#BB00BB'>PYBIND11_TOSTRING</font><font face='Lucida Console'>(</font>name<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;                    \
        <font color='#0000FF'>try</font> <b>{</b>                                                                  \
            <font color='#BB00BB'>PYBIND11_CONCAT</font><font face='Lucida Console'>(</font>pybind11_init_, name<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>m<font face='Lucida Console'>)</font>;                          \
            <font color='#0000FF'>return</font> m.<font color='#BB00BB'>ptr</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;                                                    \
        <b>}</b> <font color='#0000FF'>catch</font> <font face='Lucida Console'>(</font>pybind11::error_already_set <font color='#5555FF'>&amp;</font>e<font face='Lucida Console'>)</font> <b>{</b>                             \
            <font color='#BB00BB'>PyErr_SetString</font><font face='Lucida Console'>(</font>PyExc_ImportError, e.<font color='#BB00BB'>what</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;                      \
            <font color='#0000FF'>return</font> nullptr;                                                    \
        <b>}</b> <font color='#0000FF'>catch</font> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> std::exception <font color='#5555FF'>&amp;</font>e<font face='Lucida Console'>)</font> <b>{</b>                                    \
            <font color='#BB00BB'>PyErr_SetString</font><font face='Lucida Console'>(</font>PyExc_ImportError, e.<font color='#BB00BB'>what</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;                      \
            <font color='#0000FF'>return</font> nullptr;                                                    \
        <b>}</b>                                                                      \
    <b>}</b>                                                                          \
    <font color='#0000FF'><u>void</u></font> <b><a name='PYBIND11_CONCAT'></a>PYBIND11_CONCAT</b><font face='Lucida Console'>(</font>pybind11_init_, name<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>pybind11::module <font color='#5555FF'>&amp;</font>variable<font face='Lucida Console'>)</font>


<b><a name='NAMESPACE_BEGIN'></a>NAMESPACE_BEGIN</b><font face='Lucida Console'>(</font>PYBIND11_NAMESPACE<font face='Lucida Console'>)</font>

<font color='#0000FF'>using</font> ssize_t <font color='#5555FF'>=</font> Py_ssize_t;
<font color='#0000FF'>using</font> <font color='#0000FF'><u>size_t</u></font>  <font color='#5555FF'>=</font> std::<font color='#0000FF'><u>size_t</u></font>;

<font color='#009900'>/// Approach used to cast a previously unknown C++ instance into a Python object
</font><font color='#0000FF'>enum</font> <font color='#0000FF'>class</font> <b><a name='return_value_policy'></a>return_value_policy</b> : uint8_t <b>{</b>
    <font color='#009900'>/** This is the default return value policy, which falls back to the policy
        return_value_policy::take_ownership when the return value is a pointer.
        Otherwise, it uses return_value::move or return_value::copy for rvalue
        and lvalue references, respectively. See below for a description of what
        all of these different policies do. */</font>
    automatic <font color='#5555FF'>=</font> <font color='#979000'>0</font>,

    <font color='#009900'>/** As above, but use policy return_value_policy::reference when the return
        value is a pointer. This is the default conversion policy for function
        arguments when calling Python functions manually from C++ code (i.e. via
        handle::operator()). You probably won't need to use this. */</font>
    automatic_reference,

    <font color='#009900'>/** Reference an existing object (i.e. do not create a new copy) and take
        ownership. Python will call the destructor and delete operator when the
        object’s reference count reaches zero. Undefined behavior ensues when
        the C++ side does the same.. */</font>
    take_ownership,

    <font color='#009900'>/** Create a new copy of the returned object, which will be owned by
        Python. This policy is comparably safe because the lifetimes of the two
        instances are decoupled. */</font>
    copy,

    <font color='#009900'>/** Use std::move to move the return value contents into a new instance
        that will be owned by Python. This policy is comparably safe because the
        lifetimes of the two instances (move source and destination) are
        decoupled. */</font>
    move,

    <font color='#009900'>/** Reference an existing object, but do not take ownership. The C++ side
        is responsible for managing the object’s lifetime and deallocating it
        when it is no longer used. Warning: undefined behavior will ensue when
        the C++ side deletes an object that is still referenced and used by
        Python. */</font>
    reference,

    <font color='#009900'>/** This policy only applies to methods and properties. It references the
        object without taking ownership similar to the above
        return_value_policy::reference policy. In contrast to that policy, the
        function or property’s implicit this argument (called the parent) is
        considered to be the the owner of the return value (the child).
        pybind11 then couples the lifetime of the parent to the child via a
        reference relationship that ensures that the parent cannot be garbage
        collected while Python is still using the child. More advanced
        variations of this scheme are also possible using combinations of
        return_value_policy::reference and the keep_alive call policy */</font>
    reference_internal
<b>}</b>;

<b><a name='NAMESPACE_BEGIN'></a>NAMESPACE_BEGIN</b><font face='Lucida Console'>(</font>detail<font face='Lucida Console'>)</font>

<font color='#0000FF'>inline</font> <font color='#0000FF'>static</font> constexpr <font color='#0000FF'><u>int</u></font> <b><a name='log2'></a>log2</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>size_t</u></font> n, <font color='#0000FF'><u>int</u></font> k <font color='#5555FF'>=</font> <font color='#979000'>0</font><font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> <font face='Lucida Console'>(</font>n <font color='#5555FF'>&lt;</font><font color='#5555FF'>=</font> <font color='#979000'>1</font><font face='Lucida Console'>)</font> ? k : <font color='#BB00BB'>log2</font><font face='Lucida Console'>(</font>n <font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <font color='#979000'>1</font>, k <font color='#5555FF'>+</font> <font color='#979000'>1</font><font face='Lucida Console'>)</font>; <b>}</b>

<font color='#009900'>// Returns the size as a multiple of sizeof(void *), rounded up.
</font><font color='#0000FF'>inline</font> <font color='#0000FF'>static</font> constexpr <font color='#0000FF'><u>size_t</u></font> <b><a name='size_in_ptrs'></a>size_in_ptrs</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>size_t</u></font> s<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> <font color='#979000'>1</font> <font color='#5555FF'>+</font> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>s <font color='#5555FF'>-</font> <font color='#979000'>1</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <font color='#BB00BB'>log2</font><font face='Lucida Console'>(</font><font color='#0000FF'>sizeof</font><font face='Lucida Console'>(</font><font color='#0000FF'><u>void</u></font> <font color='#5555FF'>*</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>; <b>}</b>

<font color='#009900'>/**
 * The space to allocate for simple layout instance holders (see below) in multiple of the size of
 * a pointer (e.g.  2 means 16 bytes on 64-bit architectures).  The default is the minimum required
 * to holder either a std::unique_ptr or std::shared_ptr (which is almost always
 * sizeof(std::shared_ptr&lt;T&gt;)).
 */</font>
constexpr <font color='#0000FF'><u>size_t</u></font> <b><a name='instance_simple_holder_in_ptrs'></a>instance_simple_holder_in_ptrs</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>{</b>
    <font color='#BB00BB'>static_assert</font><font face='Lucida Console'>(</font><font color='#0000FF'>sizeof</font><font face='Lucida Console'>(</font>std::shared_ptr<font color='#5555FF'>&lt;</font><font color='#0000FF'><u>int</u></font><font color='#5555FF'>&gt;</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&gt;</font><font color='#5555FF'>=</font> <font color='#0000FF'>sizeof</font><font face='Lucida Console'>(</font>std::unique_ptr<font color='#5555FF'>&lt;</font><font color='#0000FF'><u>int</u></font><font color='#5555FF'>&gt;</font><font face='Lucida Console'>)</font>,
            "<font color='#CC0000'>pybind assumes std::shared_ptrs are at least as big as std::unique_ptrs</font>"<font face='Lucida Console'>)</font>;
    <font color='#0000FF'>return</font> <font color='#BB00BB'>size_in_ptrs</font><font face='Lucida Console'>(</font><font color='#0000FF'>sizeof</font><font face='Lucida Console'>(</font>std::shared_ptr<font color='#5555FF'>&lt;</font><font color='#0000FF'><u>int</u></font><font color='#5555FF'>&gt;</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b>}</b>

<font color='#009900'>// Forward declarations
</font><font color='#0000FF'>struct</font> type_info;
<font color='#0000FF'>struct</font> value_and_holder;

<font color='#009900'>/// The 'instance' type which needs to be standard layout (need to be able to use 'offsetof')
</font><font color='#0000FF'>struct</font> <b><a name='instance'></a>instance</b> <b>{</b>
    PyObject_HEAD
    <font color='#009900'>/// Storage for pointers and holder; see simple_layout, below, for a description
</font>    <font color='#0000FF'>union</font> <b>{</b>
        <font color='#0000FF'><u>void</u></font> <font color='#5555FF'>*</font>simple_value_holder[<font color='#979000'>1</font> <font color='#5555FF'>+</font> <font color='#BB00BB'>instance_simple_holder_in_ptrs</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>];
        <font color='#0000FF'>struct</font> <b>{</b>
            <font color='#0000FF'><u>void</u></font> <font color='#5555FF'>*</font><font color='#5555FF'>*</font>values_and_holders;
            uint8_t <font color='#5555FF'>*</font>status;
        <b>}</b> nonsimple;
    <b>}</b>;
    <font color='#009900'>/// Weak references
</font>    PyObject <font color='#5555FF'>*</font>weakrefs;
    <font color='#009900'>/// If true, the pointer is owned which means we're free to manage it with a holder.
</font>    <font color='#0000FF'><u>bool</u></font> owned : <font color='#979000'>1</font>;
    <font color='#009900'>/**
     * An instance has two possible value/holder layouts.
     *
     * Simple layout (when this flag is true), means the `simple_value_holder` is set with a pointer
     * and the holder object governing that pointer, i.e. [val1*][holder].  This layout is applied
     * whenever there is no python-side multiple inheritance of bound C++ types *and* the type's
     * holder will fit in the default space (which is large enough to hold either a std::unique_ptr
     * or std::shared_ptr).
     *
     * Non-simple layout applies when using custom holders that require more space than `shared_ptr`
     * (which is typically the size of two pointers), or when multiple inheritance is used on the
     * python side.  Non-simple layout allocates the required amount of memory to have multiple
     * bound C++ classes as parents.  Under this layout, `nonsimple.values_and_holders` is set to a
     * pointer to allocated space of the required space to hold a sequence of value pointers and
     * holders followed `status`, a set of bit flags (1 byte each), i.e.
     * [val1*][holder1][val2*][holder2]...[bb...]  where each [block] is rounded up to a multiple of
     * `sizeof(void *)`.  `nonsimple.status` is, for convenience, a pointer to the
     * beginning of the [bb...] block (but not independently allocated).
     *
     * Status bits indicate whether the associated holder is constructed (&amp;
     * status_holder_constructed) and whether the value pointer is registered (&amp;
     * status_instance_registered) in `registered_instances`.
     */</font>
    <font color='#0000FF'><u>bool</u></font> simple_layout : <font color='#979000'>1</font>;
    <font color='#009900'>/// For simple layout, tracks whether the holder has been constructed
</font>    <font color='#0000FF'><u>bool</u></font> simple_holder_constructed : <font color='#979000'>1</font>;
    <font color='#009900'>/// For simple layout, tracks whether the instance is registered in `registered_instances`
</font>    <font color='#0000FF'><u>bool</u></font> simple_instance_registered : <font color='#979000'>1</font>;
    <font color='#009900'>/// If true, get_internals().patients has an entry for this object
</font>    <font color='#0000FF'><u>bool</u></font> has_patients : <font color='#979000'>1</font>;

    <font color='#009900'>/// Initializes all of the above type/values/holders data (but not the instance values themselves)
</font>    <font color='#0000FF'><u>void</u></font> <b><a name='allocate_layout'></a>allocate_layout</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;

    <font color='#009900'>/// Destroys/deallocates all of the above
</font>    <font color='#0000FF'><u>void</u></font> <b><a name='deallocate_layout'></a>deallocate_layout</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;

    <font color='#009900'>/// Returns the value_and_holder wrapper for the given type (or the first, if `find_type`
</font>    <font color='#009900'>/// omitted).  Returns a default-constructed (with `.inst = nullptr`) object on failure if
</font>    <font color='#009900'>/// `throw_if_missing` is false.
</font>    value_and_holder <b><a name='get_value_and_holder'></a>get_value_and_holder</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> type_info <font color='#5555FF'>*</font>find_type <font color='#5555FF'>=</font> nullptr, <font color='#0000FF'><u>bool</u></font> throw_if_missing <font color='#5555FF'>=</font> <font color='#979000'>true</font><font face='Lucida Console'>)</font>;

    <font color='#009900'>/// Bit values for the non-simple status flags
</font>    <font color='#0000FF'>static</font> constexpr uint8_t status_holder_constructed  <font color='#5555FF'>=</font> <font color='#979000'>1</font>;
    <font color='#0000FF'>static</font> constexpr uint8_t status_instance_registered <font color='#5555FF'>=</font> <font color='#979000'>2</font>;
<b>}</b>;

<b><a name='static_assert'></a>static_assert</b><font face='Lucida Console'>(</font>std::is_standard_layout<font color='#5555FF'>&lt;</font>instance<font color='#5555FF'>&gt;</font>::value, "<font color='#CC0000'>Internal error: `pybind11::detail::instance` is not standard layout!</font>"<font face='Lucida Console'>)</font>;

<font color='#009900'>/// from __cpp_future__ import (convenient aliases from C++14/17)
</font><font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PYBIND11_CPP14<font face='Lucida Console'>)</font> <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> <font face='Lucida Console'>(</font><font color='#5555FF'>!</font>defined<font face='Lucida Console'>(</font>_MSC_VER<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> _MSC_VER <font color='#5555FF'>&gt;</font><font color='#5555FF'>=</font> <font color='#979000'>1910</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>using</font> std::enable_if_t;
<font color='#0000FF'>using</font> std::conditional_t;
<font color='#0000FF'>using</font> std::remove_cv_t;
<font color='#0000FF'>using</font> std::remove_reference_t;
<font color='#0000FF'>#else</font>
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'><u>bool</u></font> B, <font color='#0000FF'>typename</font> T <font color='#5555FF'>=</font> <font color='#0000FF'><u>void</u></font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> enable_if_t <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> std::enable_if<font color='#5555FF'>&lt;</font>B, T<font color='#5555FF'>&gt;</font>::type;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'><u>bool</u></font> B, <font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> F<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> conditional_t <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> std::conditional<font color='#5555FF'>&lt;</font>B, T, F<font color='#5555FF'>&gt;</font>::type;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> remove_cv_t <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> std::remove_cv<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::type;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> remove_reference_t <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> std::remove_reference<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::type;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/// Index sequences
</font><font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PYBIND11_CPP14<font face='Lucida Console'>)</font>
<font color='#0000FF'>using</font> std::index_sequence;
<font color='#0000FF'>using</font> std::make_index_sequence;
<font color='#0000FF'>#else</font>
<font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'><u>size_t</u></font> ...<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='index_sequence'></a>index_sequence</b>  <b>{</b> <b>}</b>;
<font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'><u>size_t</u></font> N, <font color='#0000FF'><u>size_t</u></font> ...S<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='make_index_sequence_impl'></a>make_index_sequence_impl</b> : make_index_sequence_impl <font color='#5555FF'>&lt;</font>N <font color='#5555FF'>-</font> <font color='#979000'>1</font>, N <font color='#5555FF'>-</font> <font color='#979000'>1</font>, S...<font color='#5555FF'>&gt;</font> <b>{</b> <b>}</b>;
<font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'><u>size_t</u></font> ...S<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='make_index_sequence_impl'></a>make_index_sequence_impl</b> <font color='#5555FF'>&lt;</font><font color='#979000'>0</font>, S...<font color='#5555FF'>&gt;</font> <b>{</b> <font color='#0000FF'>typedef</font> index_sequence<font color='#5555FF'>&lt;</font>S...<font color='#5555FF'>&gt;</font> type; <b>}</b>;
<font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'><u>size_t</u></font> N<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> make_index_sequence <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> make_index_sequence_impl<font color='#5555FF'>&lt;</font>N<font color='#5555FF'>&gt;</font>::type;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/// Make an index sequence of the indices of true arguments
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> ISeq, <font color='#0000FF'><u>size_t</u></font>, <font color='#0000FF'><u>bool</u></font>...<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='select_indices_impl'></a>select_indices_impl</b> <b>{</b> <font color='#0000FF'>using</font> type <font color='#5555FF'>=</font> ISeq; <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'><u>size_t</u></font>... IPrev, <font color='#0000FF'><u>size_t</u></font> I, <font color='#0000FF'><u>bool</u></font> B, <font color='#0000FF'><u>bool</u></font>... Bs<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='select_indices_impl'></a>select_indices_impl</b><font color='#5555FF'>&lt;</font>index_sequence<font color='#5555FF'>&lt;</font>IPrev...<font color='#5555FF'>&gt;</font>, I, B, Bs...<font color='#5555FF'>&gt;</font>
    : select_indices_impl<font color='#5555FF'>&lt;</font>conditional_t<font color='#5555FF'>&lt;</font>B, index_sequence<font color='#5555FF'>&lt;</font>IPrev..., I<font color='#5555FF'>&gt;</font>, index_sequence<font color='#5555FF'>&lt;</font>IPrev...<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>, I <font color='#5555FF'>+</font> <font color='#979000'>1</font>, Bs...<font color='#5555FF'>&gt;</font> <b>{</b><b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'><u>bool</u></font>... Bs<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> select_indices <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> select_indices_impl<font color='#5555FF'>&lt;</font>index_sequence<font color='#5555FF'>&lt;</font><font color='#5555FF'>&gt;</font>, <font color='#979000'>0</font>, Bs...<font color='#5555FF'>&gt;</font>::type;

<font color='#009900'>/// Backports of std::bool_constant and std::negation to accommodate older compilers
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'><u>bool</u></font> B<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> bool_constant <font color='#5555FF'>=</font> std::integral_constant<font color='#5555FF'>&lt;</font><font color='#0000FF'><u>bool</u></font>, B<font color='#5555FF'>&gt;</font>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='negation'></a>negation</b> : bool_constant<font color='#5555FF'>&lt;</font><font color='#5555FF'>!</font>T::value<font color='#5555FF'>&gt;</font> <b>{</b> <b>}</b>;

<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font>...<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='void_t_impl'></a>void_t_impl</b> <b>{</b> <font color='#0000FF'>using</font> type <font color='#5555FF'>=</font> <font color='#0000FF'><u>void</u></font>; <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font>... Ts<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> void_t <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> void_t_impl<font color='#5555FF'>&lt;</font>Ts...<font color='#5555FF'>&gt;</font>::type;

<font color='#009900'>/// Compile-time all/any/none of that check the boolean value of all template types
</font><font color='#0000FF'>#ifdef</font> __cpp_fold_expressions
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>class</font>... <b><a name='Ts'></a>Ts</b><font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> all_of <font color='#5555FF'>=</font> bool_constant<font color='#5555FF'>&lt;</font><font face='Lucida Console'>(</font>Ts::value <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> ...<font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>class</font>... <b><a name='Ts'></a>Ts</b><font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> any_of <font color='#5555FF'>=</font> bool_constant<font color='#5555FF'>&lt;</font><font face='Lucida Console'>(</font>Ts::value <font color='#5555FF'>|</font><font color='#5555FF'>|</font> ...<font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font>;
<font color='#0000FF'>#elif</font> <font color='#5555FF'>!</font>defined<font face='Lucida Console'>(</font>_MSC_VER<font face='Lucida Console'>)</font>
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'><u>bool</u></font>...<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='bools'></a>bools</b> <b>{</b><b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>class</font>... <b><a name='Ts'></a>Ts</b><font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> all_of <font color='#5555FF'>=</font> std::is_same<font color='#5555FF'>&lt;</font>
    bools<font color='#5555FF'>&lt;</font>Ts::value..., <font color='#979000'>true</font><font color='#5555FF'>&gt;</font>,
    bools<font color='#5555FF'>&lt;</font><font color='#979000'>true</font>, Ts::value...<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>class</font>... <b><a name='Ts'></a>Ts</b><font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> any_of <font color='#5555FF'>=</font> negation<font color='#5555FF'>&lt;</font>all_of<font color='#5555FF'>&lt;</font>negation<font color='#5555FF'>&lt;</font>Ts<font color='#5555FF'>&gt;</font>...<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>;
<font color='#0000FF'>#else</font>
<font color='#009900'>// MSVC has trouble with the above, but supports std::conjunction, which we can use instead (albeit
</font><font color='#009900'>// at a slight loss of compilation efficiency).
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>class</font>... <b><a name='Ts'></a>Ts</b><font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> all_of <font color='#5555FF'>=</font> std::conjunction<font color='#5555FF'>&lt;</font>Ts...<font color='#5555FF'>&gt;</font>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>class</font>... <b><a name='Ts'></a>Ts</b><font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> any_of <font color='#5555FF'>=</font> std::disjunction<font color='#5555FF'>&lt;</font>Ts...<font color='#5555FF'>&gt;</font>;
<font color='#0000FF'>#endif</font>
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>class</font>... <b><a name='Ts'></a>Ts</b><font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> none_of <font color='#5555FF'>=</font> negation<font color='#5555FF'>&lt;</font>any_of<font color='#5555FF'>&lt;</font>Ts...<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>;

<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>class</font> <b><a name='T'></a>T</b>, <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>class</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font>... <b><a name='Predicates'></a>Predicates</b><font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> satisfies_all_of <font color='#5555FF'>=</font> all_of<font color='#5555FF'>&lt;</font>Predicates<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>...<font color='#5555FF'>&gt;</font>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>class</font> <b><a name='T'></a>T</b>, <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>class</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font>... <b><a name='Predicates'></a>Predicates</b><font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> satisfies_any_of <font color='#5555FF'>=</font> any_of<font color='#5555FF'>&lt;</font>Predicates<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>...<font color='#5555FF'>&gt;</font>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>class</font> <b><a name='T'></a>T</b>, <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>class</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font>... <b><a name='Predicates'></a>Predicates</b><font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> satisfies_none_of <font color='#5555FF'>=</font> none_of<font color='#5555FF'>&lt;</font>Predicates<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>...<font color='#5555FF'>&gt;</font>;

<font color='#009900'>/// Strip the class from a method type
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='remove_class'></a>remove_class</b> <b>{</b> <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> C, <font color='#0000FF'>typename</font> R, <font color='#0000FF'>typename</font>... A<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='remove_class'></a>remove_class</b><font color='#5555FF'>&lt;</font><b><a name='R'></a>R</b> <font face='Lucida Console'>(</font>C::<font color='#5555FF'>*</font><font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>A...<font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font> <b>{</b> <font color='#0000FF'>typedef</font> R <font color='#BB00BB'>type</font><font face='Lucida Console'>(</font>A...<font face='Lucida Console'>)</font>; <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> C, <font color='#0000FF'>typename</font> R, <font color='#0000FF'>typename</font>... A<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='remove_class'></a>remove_class</b><font color='#5555FF'>&lt;</font><b><a name='R'></a>R</b> <font face='Lucida Console'>(</font>C::<font color='#5555FF'>*</font><font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>A...<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font><font color='#5555FF'>&gt;</font> <b>{</b> <font color='#0000FF'>typedef</font> R <font color='#BB00BB'>type</font><font face='Lucida Console'>(</font>A...<font face='Lucida Console'>)</font>; <b>}</b>;

<font color='#009900'>/// Helper template to strip away type modifiers
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='intrinsic_type'></a>intrinsic_type</b>                       <b>{</b> <font color='#0000FF'>typedef</font> T type; <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='intrinsic_type'></a>intrinsic_type</b><font color='#5555FF'>&lt;</font><font color='#0000FF'>const</font> T<font color='#5555FF'>&gt;</font>              <b>{</b> <font color='#0000FF'>typedef</font> <font color='#0000FF'>typename</font> intrinsic_type<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::type type; <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='intrinsic_type'></a>intrinsic_type</b><font color='#5555FF'>&lt;</font>T<font color='#5555FF'>*</font><font color='#5555FF'>&gt;</font>                   <b>{</b> <font color='#0000FF'>typedef</font> <font color='#0000FF'>typename</font> intrinsic_type<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::type type; <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='intrinsic_type'></a>intrinsic_type</b><font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&amp;</font><font color='#5555FF'>&gt;</font>                   <b>{</b> <font color='#0000FF'>typedef</font> <font color='#0000FF'>typename</font> intrinsic_type<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::type type; <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='intrinsic_type'></a>intrinsic_type</b><font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font><font color='#5555FF'>&gt;</font>                  <b>{</b> <font color='#0000FF'>typedef</font> <font color='#0000FF'>typename</font> intrinsic_type<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::type type; <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'><u>size_t</u></font> N<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='intrinsic_type'></a>intrinsic_type</b><font color='#5555FF'>&lt;</font><font color='#0000FF'>const</font> T[N]<font color='#5555FF'>&gt;</font> <b>{</b> <font color='#0000FF'>typedef</font> <font color='#0000FF'>typename</font> intrinsic_type<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::type type; <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'><u>size_t</u></font> N<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='intrinsic_type'></a>intrinsic_type</b><font color='#5555FF'>&lt;</font>T[N]<font color='#5555FF'>&gt;</font>       <b>{</b> <font color='#0000FF'>typedef</font> <font color='#0000FF'>typename</font> intrinsic_type<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::type type; <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> intrinsic_t <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> intrinsic_type<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::type;

<font color='#009900'>/// Helper type to replace 'void' in some expressions
</font><font color='#0000FF'>struct</font> <b><a name='void_type'></a>void_type</b> <b>{</b> <b>}</b>;

<font color='#009900'>/// Helper template which holds a list of types
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font>...<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='type_list'></a>type_list</b> <b>{</b> <b>}</b>;

<font color='#009900'>/// Compile-time integer sum
</font><font color='#0000FF'>#ifdef</font> __cpp_fold_expressions
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font>... Ts<font color='#5555FF'>&gt;</font> constexpr <font color='#0000FF'><u>size_t</u></font> <b><a name='constexpr_sum'></a>constexpr_sum</b><font face='Lucida Console'>(</font>Ts... ns<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> <font face='Lucida Console'>(</font><font color='#979000'>0</font> <font color='#5555FF'>+</font> ... <font color='#5555FF'>+</font> <font color='#0000FF'><u>size_t</u></font><b>{</b>ns<b>}</b><font face='Lucida Console'>)</font>; <b>}</b>
<font color='#0000FF'>#else</font>
constexpr <font color='#0000FF'><u>size_t</u></font> <b><a name='constexpr_sum'></a>constexpr_sum</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> <font color='#979000'>0</font>; <b>}</b>
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font>... Ts<font color='#5555FF'>&gt;</font>
constexpr <font color='#0000FF'><u>size_t</u></font> <b><a name='constexpr_sum'></a>constexpr_sum</b><font face='Lucida Console'>(</font>T n, Ts... ns<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> <font color='#0000FF'><u>size_t</u></font><b>{</b>n<b>}</b> <font color='#5555FF'>+</font> <font color='#BB00BB'>constexpr_sum</font><font face='Lucida Console'>(</font>ns...<font face='Lucida Console'>)</font>; <b>}</b>
<font color='#0000FF'>#endif</font>

<b><a name='NAMESPACE_BEGIN'></a>NAMESPACE_BEGIN</b><font face='Lucida Console'>(</font>constexpr_impl<font face='Lucida Console'>)</font>
<font color='#009900'>/// Implementation details for constexpr functions
</font>constexpr <font color='#0000FF'><u>int</u></font> <b><a name='first'></a>first</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>int</u></font> i<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> i; <b>}</b>
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font>... Ts<font color='#5555FF'>&gt;</font>
constexpr <font color='#0000FF'><u>int</u></font> <b><a name='first'></a>first</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>int</u></font> i, T v, Ts... vs<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> v ? i : <font color='#BB00BB'>first</font><font face='Lucida Console'>(</font>i <font color='#5555FF'>+</font> <font color='#979000'>1</font>, vs...<font face='Lucida Console'>)</font>; <b>}</b>

constexpr <font color='#0000FF'><u>int</u></font> <b><a name='last'></a>last</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>int</u></font> <font color='#009900'>/*i*/</font>, <font color='#0000FF'><u>int</u></font> result<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> result; <b>}</b>
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font>... Ts<font color='#5555FF'>&gt;</font>
constexpr <font color='#0000FF'><u>int</u></font> <b><a name='last'></a>last</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>int</u></font> i, <font color='#0000FF'><u>int</u></font> result, T v, Ts... vs<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> <font color='#BB00BB'>last</font><font face='Lucida Console'>(</font>i <font color='#5555FF'>+</font> <font color='#979000'>1</font>, v ? i : result, vs...<font face='Lucida Console'>)</font>; <b>}</b>
<b><a name='NAMESPACE_END'></a>NAMESPACE_END</b><font face='Lucida Console'>(</font>constexpr_impl<font face='Lucida Console'>)</font>

<font color='#009900'>/// Return the index of the first type in Ts which satisfies Predicate&lt;T&gt;.  Returns sizeof...(Ts) if
</font><font color='#009900'>/// none match.
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='Predicate'></a>Predicate</b>, <font color='#0000FF'>typename</font>... Ts<font color='#5555FF'>&gt;</font>
constexpr <font color='#0000FF'><u>int</u></font> <b><a name='constexpr_first'></a>constexpr_first</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> constexpr_impl::<font color='#BB00BB'>first</font><font face='Lucida Console'>(</font><font color='#979000'>0</font>, Predicate<font color='#5555FF'>&lt;</font>Ts<font color='#5555FF'>&gt;</font>::value...<font face='Lucida Console'>)</font>; <b>}</b>

<font color='#009900'>/// Return the index of the last type in Ts which satisfies Predicate&lt;T&gt;, or -1 if none match.
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='Predicate'></a>Predicate</b>, <font color='#0000FF'>typename</font>... Ts<font color='#5555FF'>&gt;</font>
constexpr <font color='#0000FF'><u>int</u></font> <b><a name='constexpr_last'></a>constexpr_last</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> constexpr_impl::<font color='#BB00BB'>last</font><font face='Lucida Console'>(</font><font color='#979000'>0</font>, <font color='#5555FF'>-</font><font color='#979000'>1</font>, Predicate<font color='#5555FF'>&lt;</font>Ts<font color='#5555FF'>&gt;</font>::value...<font face='Lucida Console'>)</font>; <b>}</b>

<font color='#009900'>/// Return the Nth element from the parameter pack
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'><u>size_t</u></font> N, <font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font>... Ts<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='pack_element'></a>pack_element</b> <b>{</b> <font color='#0000FF'>using</font> type <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> pack_element<font color='#5555FF'>&lt;</font>N <font color='#5555FF'>-</font> <font color='#979000'>1</font>, Ts...<font color='#5555FF'>&gt;</font>::type; <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font>... Ts<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='pack_element'></a>pack_element</b><font color='#5555FF'>&lt;</font><font color='#979000'>0</font>, T, Ts...<font color='#5555FF'>&gt;</font> <b>{</b> <font color='#0000FF'>using</font> type <font color='#5555FF'>=</font> T; <b>}</b>;

<font color='#009900'>/// Return the one and only type which matches the predicate, or Default if none match.
</font><font color='#009900'>/// If more than one type matches the predicate, fail at compile-time.
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='Predicate'></a>Predicate</b>, <font color='#0000FF'>typename</font> Default, <font color='#0000FF'>typename</font>... Ts<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='exactly_one'></a>exactly_one</b> <b>{</b>
    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'>auto</font> found <font color='#5555FF'>=</font> <b><a name='constexpr_sum'></a>constexpr_sum</b><font face='Lucida Console'>(</font>Predicate<font color='#5555FF'>&lt;</font>Ts<font color='#5555FF'>&gt;</font>::value...<font face='Lucida Console'>)</font>;
    <b><a name='static_assert'></a>static_assert</b><font face='Lucida Console'>(</font>found <font color='#5555FF'>&lt;</font><font color='#5555FF'>=</font> <font color='#979000'>1</font>, "<font color='#CC0000'>Found more than one type matching the predicate</font>"<font face='Lucida Console'>)</font>;

    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'>auto</font> index <font color='#5555FF'>=</font> found ? constexpr_first<font color='#5555FF'>&lt;</font>Predicate, Ts...<font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> : <font color='#979000'>0</font>;
    <font color='#0000FF'>using</font> type <font color='#5555FF'>=</font> conditional_t<font color='#5555FF'>&lt;</font>found, <font color='#0000FF'>typename</font> pack_element<font color='#5555FF'>&lt;</font>index, Ts...<font color='#5555FF'>&gt;</font>::type, Default<font color='#5555FF'>&gt;</font>;
<b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='P'></a>P</b>, <font color='#0000FF'>typename</font> Default<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='exactly_one'></a>exactly_one</b><font color='#5555FF'>&lt;</font>P, Default<font color='#5555FF'>&gt;</font> <b>{</b> <font color='#0000FF'>using</font> type <font color='#5555FF'>=</font> Default; <b>}</b>;

<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='Predicate'></a>Predicate</b>, <font color='#0000FF'>typename</font> Default, <font color='#0000FF'>typename</font>... Ts<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>using</font> exactly_one_t <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> exactly_one<font color='#5555FF'>&lt;</font>Predicate, Default, Ts...<font color='#5555FF'>&gt;</font>::type;

<font color='#009900'>/// Defer the evaluation of type T until types Us are instantiated
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font>... <font color='#009900'>/*Us*/</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='deferred_type'></a>deferred_type</b> <b>{</b> <font color='#0000FF'>using</font> type <font color='#5555FF'>=</font> T; <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font>... Us<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> deferred_t <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> deferred_type<font color='#5555FF'>&lt;</font>T, Us...<font color='#5555FF'>&gt;</font>::type;

<font color='#009900'>/// Like is_base_of, but requires a strict base (i.e. `is_strict_base_of&lt;T, T&gt;::value == false`,
</font><font color='#009900'>/// unlike `std::is_base_of`)
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> Base, <font color='#0000FF'>typename</font> Derived<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> is_strict_base_of <font color='#5555FF'>=</font> bool_constant<font color='#5555FF'>&lt;</font>
    std::is_base_of<font color='#5555FF'>&lt;</font>Base, Derived<font color='#5555FF'>&gt;</font>::value <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> <font color='#5555FF'>!</font>std::is_same<font color='#5555FF'>&lt;</font>Base, Derived<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font>;

<font color='#009900'>/// Like is_base_of, but also requires that the base type is accessible (i.e. that a Derived pointer
</font><font color='#009900'>/// can be converted to a Base pointer)
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> Base, <font color='#0000FF'>typename</font> Derived<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> is_accessible_base_of <font color='#5555FF'>=</font> bool_constant<font color='#5555FF'>&lt;</font>
    std::is_base_of<font color='#5555FF'>&lt;</font>Base, Derived<font color='#5555FF'>&gt;</font>::value <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> std::is_convertible<font color='#5555FF'>&lt;</font>Derived <font color='#5555FF'>*</font>, Base <font color='#5555FF'>*</font><font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font>;

<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font>...<font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='Base'></a>Base</b><font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='is_template_base_of_impl'></a>is_template_base_of_impl</b> <b>{</b>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font>... Us<font color='#5555FF'>&gt;</font> <font color='#0000FF'>static</font> std::true_type <b><a name='check'></a>check</b><font face='Lucida Console'>(</font>Base<font color='#5555FF'>&lt;</font>Us...<font color='#5555FF'>&gt;</font> <font color='#5555FF'>*</font><font face='Lucida Console'>)</font>;
    <font color='#0000FF'>static</font> std::false_type <b><a name='check'></a>check</b><font face='Lucida Console'>(</font>...<font face='Lucida Console'>)</font>;
<b>}</b>;

<font color='#009900'>/// Check if a template is the base of a type. For example:
</font><font color='#009900'>/// `is_template_base_of&lt;Base, T&gt;` is true if `struct T : Base&lt;U&gt; {}` where U can be anything
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font>...<font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='Base'></a>Base</b>, <font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#if</font> <font color='#5555FF'>!</font>defined<font face='Lucida Console'>(</font>_MSC_VER<font face='Lucida Console'>)</font>
<font color='#0000FF'>using</font> is_template_base_of <font color='#5555FF'>=</font> <b><a name='decltype'></a>decltype</b><font face='Lucida Console'>(</font>is_template_base_of_impl<font color='#5555FF'>&lt;</font>Base<font color='#5555FF'>&gt;</font>::<font color='#BB00BB'>check</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>intrinsic_t<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font><font color='#5555FF'>*</font><font face='Lucida Console'>)</font>nullptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#else</font> <font color='#009900'>// MSVC2015 has trouble with decltype in template aliases
</font><font color='#0000FF'>struct</font> <b><a name='is_template_base_of'></a>is_template_base_of</b> : <b><a name='decltype'></a>decltype</b><font face='Lucida Console'>(</font>is_template_base_of_impl<font color='#5555FF'>&lt;</font>Base<font color='#5555FF'>&gt;</font>::<font color='#BB00BB'>check</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>intrinsic_t<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font><font color='#5555FF'>*</font><font face='Lucida Console'>)</font>nullptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <b>{</b> <b>}</b>;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/// Check if T is an instantiation of the template `Class`. For example:
</font><font color='#009900'>/// `is_instantiation&lt;shared_ptr, T&gt;` is true if `T == shared_ptr&lt;U&gt;` where U can be anything.
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font>...<font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='Class'></a>Class</b>, <font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='is_instantiation'></a>is_instantiation</b> : std::false_type <b>{</b> <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font>...<font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='Class'></a>Class</b>, <font color='#0000FF'>typename</font>... Us<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='is_instantiation'></a>is_instantiation</b><font color='#5555FF'>&lt;</font>Class, Class<font color='#5555FF'>&lt;</font>Us...<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> : std::true_type <b>{</b> <b>}</b>;

<font color='#009900'>/// Check if T is std::shared_ptr&lt;U&gt; where U can be anything
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> is_shared_ptr <font color='#5555FF'>=</font> is_instantiation<font color='#5555FF'>&lt;</font>std::shared_ptr, T<font color='#5555FF'>&gt;</font>;

<font color='#009900'>/// Check if T looks like an input iterator
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> <font color='#5555FF'>=</font> <font color='#0000FF'><u>void</u></font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='is_input_iterator'></a>is_input_iterator</b> : std::false_type <b>{</b><b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='is_input_iterator'></a>is_input_iterator</b><font color='#5555FF'>&lt;</font>T, void_t<font color='#5555FF'>&lt;</font><b><a name='decltype'></a>decltype</b><font face='Lucida Console'>(</font><font color='#5555FF'>*</font>std::declval<font color='#5555FF'>&lt;</font>T <font color='#5555FF'>&amp;</font><font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>, <b><a name='decltype'></a>decltype</b><font face='Lucida Console'>(</font><font color='#5555FF'>+</font><font color='#5555FF'>+</font>std::declval<font color='#5555FF'>&lt;</font>T <font color='#5555FF'>&amp;</font><font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>
    : std::true_type <b>{</b><b>}</b>;

<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> is_function_pointer <font color='#5555FF'>=</font> bool_constant<font color='#5555FF'>&lt;</font>
    std::is_pointer<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::value <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> std::is_function<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> std::remove_pointer<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::type<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font>;

<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> F<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='strip_function_object'></a>strip_function_object</b> <b>{</b>
    <font color='#0000FF'>using</font> type <font color='#5555FF'>=</font> <font color='#0000FF'>typename</font> remove_class<font color='#5555FF'>&lt;</font><b><a name='decltype'></a>decltype</b><font face='Lucida Console'>(</font><font color='#5555FF'>&amp;</font>F::<b><a name='operator'></a>operator</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font>::type;
<b>}</b>;

<font color='#009900'>// Extracts the function signature from a function, function pointer or lambda.
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> Function, <font color='#0000FF'>typename</font> F <font color='#5555FF'>=</font> remove_reference_t<font color='#5555FF'>&lt;</font>Function<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>
<font color='#0000FF'>using</font> function_signature_t <font color='#5555FF'>=</font> conditional_t<font color='#5555FF'>&lt;</font>
    std::is_function<font color='#5555FF'>&lt;</font>F<font color='#5555FF'>&gt;</font>::value,
    F,
    <font color='#0000FF'>typename</font> conditional_t<font color='#5555FF'>&lt;</font>
        std::is_pointer<font color='#5555FF'>&lt;</font>F<font color='#5555FF'>&gt;</font>::value <font color='#5555FF'>|</font><font color='#5555FF'>|</font> std::is_member_pointer<font color='#5555FF'>&lt;</font>F<font color='#5555FF'>&gt;</font>::value,
        std::remove_pointer<font color='#5555FF'>&lt;</font>F<font color='#5555FF'>&gt;</font>,
        strip_function_object<font color='#5555FF'>&lt;</font>F<font color='#5555FF'>&gt;</font>
    <font color='#5555FF'>&gt;</font>::type
<font color='#5555FF'>&gt;</font>;

<font color='#009900'>/// Returns true if the type looks like a lambda: that is, isn't a function, pointer or member
</font><font color='#009900'>/// pointer.  Note that this can catch all sorts of other things, too; this is intended to be used
</font><font color='#009900'>/// in a place where passing a lambda makes sense.
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> is_lambda <font color='#5555FF'>=</font> satisfies_none_of<font color='#5555FF'>&lt;</font>remove_reference_t<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>,
        std::is_function, std::is_pointer, std::is_member_pointer<font color='#5555FF'>&gt;</font>;

<font color='#009900'>/// Ignore that a variable is unused in compiler warnings
</font><font color='#0000FF'>inline</font> <font color='#0000FF'><u>void</u></font> <b><a name='ignore_unused'></a>ignore_unused</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font><font face='Lucida Console'>)</font> <b>{</b> <b>}</b>

<font color='#009900'>/// Apply a function over each element of a parameter pack
</font><font color='#0000FF'>#ifdef</font> __cpp_fold_expressions
<font color='#0000FF'>#define</font> PYBIND11_EXPAND_SIDE_EFFECTS<font face='Lucida Console'>(</font>PATTERN<font face='Lucida Console'>)</font> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>PATTERN<font face='Lucida Console'>)</font>, <font color='#0000FF'><u>void</u></font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>, ...<font face='Lucida Console'>)</font>
<font color='#0000FF'>#else</font>
<font color='#0000FF'>using</font> expand_side_effects <font color='#5555FF'>=</font> <font color='#0000FF'><u>bool</u></font>[];
<font color='#0000FF'>#define</font> PYBIND11_EXPAND_SIDE_EFFECTS<font face='Lucida Console'>(</font>PATTERN<font face='Lucida Console'>)</font> pybind11::detail::expand_side_effects<b>{</b> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>PATTERN<font face='Lucida Console'>)</font>, <font color='#0000FF'><u>void</u></font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, <font color='#979000'>false</font><font face='Lucida Console'>)</font>..., <font color='#979000'>false</font> <b>}</b>
<font color='#0000FF'>#endif</font>

<b><a name='NAMESPACE_END'></a>NAMESPACE_END</b><font face='Lucida Console'>(</font>detail<font face='Lucida Console'>)</font>

<font color='#009900'>/// C++ bindings of builtin Python exceptions
</font><font color='#0000FF'>class</font> <b><a name='builtin_exception'></a>builtin_exception</b> : <font color='#0000FF'>public</font> std::runtime_error <b>{</b>
<font color='#0000FF'>public</font>:
    <font color='#0000FF'>using</font> std::runtime_error::runtime_error;
    <font color='#009900'>/// Set the error using the Python C API
</font>    <font color='#0000FF'>virtual</font> <font color='#0000FF'><u>void</u></font> <b><a name='set_error'></a>set_error</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font> <font color='#5555FF'>=</font> <font color='#979000'>0</font>;
<b>}</b>;

<font color='#0000FF'>#define</font> PYBIND11_RUNTIME_EXCEPTION<font face='Lucida Console'>(</font>name, type<font face='Lucida Console'>)</font> \
    <font color='#0000FF'>class</font> <b><a name='name'></a>name</b> : <font color='#0000FF'>public</font> builtin_exception <b>{</b> <font color='#0000FF'>public</font>: \
        <font color='#0000FF'>using</font> builtin_exception::builtin_exception; \
        <b><a name='name'></a>name</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> : name<font face='Lucida Console'>(</font>"<font color='#CC0000'></font>"<font face='Lucida Console'>)</font> <b>{</b> <b>}</b> \
        <font color='#0000FF'><u>void</u></font> <b><a name='set_error'></a>set_error</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font> override <b>{</b> <font color='#BB00BB'>PyErr_SetString</font><font face='Lucida Console'>(</font>type, <font color='#BB00BB'>what</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>; <b>}</b> \
    <b>}</b>;

<b><a name='PYBIND11_RUNTIME_EXCEPTION'></a>PYBIND11_RUNTIME_EXCEPTION</b><font face='Lucida Console'>(</font>stop_iteration, PyExc_StopIteration<font face='Lucida Console'>)</font>
<b><a name='PYBIND11_RUNTIME_EXCEPTION'></a>PYBIND11_RUNTIME_EXCEPTION</b><font face='Lucida Console'>(</font>index_error, PyExc_IndexError<font face='Lucida Console'>)</font>
<b><a name='PYBIND11_RUNTIME_EXCEPTION'></a>PYBIND11_RUNTIME_EXCEPTION</b><font face='Lucida Console'>(</font>key_error, PyExc_KeyError<font face='Lucida Console'>)</font>
<b><a name='PYBIND11_RUNTIME_EXCEPTION'></a>PYBIND11_RUNTIME_EXCEPTION</b><font face='Lucida Console'>(</font>value_error, PyExc_ValueError<font face='Lucida Console'>)</font>
<b><a name='PYBIND11_RUNTIME_EXCEPTION'></a>PYBIND11_RUNTIME_EXCEPTION</b><font face='Lucida Console'>(</font>type_error, PyExc_TypeError<font face='Lucida Console'>)</font>
<b><a name='PYBIND11_RUNTIME_EXCEPTION'></a>PYBIND11_RUNTIME_EXCEPTION</b><font face='Lucida Console'>(</font>cast_error, PyExc_RuntimeError<font face='Lucida Console'>)</font> <font color='#009900'>/// Thrown when pybind11::cast or handle::call fail due to a type casting error
</font><b><a name='PYBIND11_RUNTIME_EXCEPTION'></a>PYBIND11_RUNTIME_EXCEPTION</b><font face='Lucida Console'>(</font>reference_cast_error, PyExc_RuntimeError<font face='Lucida Console'>)</font> <font color='#009900'>/// Used internally
</font>
[[noreturn]] PYBIND11_NOINLINE <font color='#0000FF'>inline</font> <font color='#0000FF'><u>void</u></font> <b><a name='pybind11_fail'></a>pybind11_fail</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> <font color='#0000FF'><u>char</u></font> <font color='#5555FF'>*</font>reason<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>throw</font> std::<font color='#BB00BB'>runtime_error</font><font face='Lucida Console'>(</font>reason<font face='Lucida Console'>)</font>; <b>}</b>
[[noreturn]] PYBIND11_NOINLINE <font color='#0000FF'>inline</font> <font color='#0000FF'><u>void</u></font> <b><a name='pybind11_fail'></a>pybind11_fail</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> std::string <font color='#5555FF'>&amp;</font>reason<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>throw</font> std::<font color='#BB00BB'>runtime_error</font><font face='Lucida Console'>(</font>reason<font face='Lucida Console'>)</font>; <b>}</b>

<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> SFINAE <font color='#5555FF'>=</font> <font color='#0000FF'><u>void</u></font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='format_descriptor'></a>format_descriptor</b> <b>{</b> <b>}</b>;

<b><a name='NAMESPACE_BEGIN'></a>NAMESPACE_BEGIN</b><font face='Lucida Console'>(</font>detail<font face='Lucida Console'>)</font>
<font color='#009900'>// Returns the index of the given type in the type char array below, and in the list in numpy.h
</font><font color='#009900'>// The order here is: bool; 8 ints ((signed,unsigned)x(8,16,32,64)bits); float,double,long double;
</font><font color='#009900'>// complex float,double,long double.  Note that the long double types only participate when long
</font><font color='#009900'>// double is actually longer than double (it isn't under MSVC).
</font><font color='#009900'>// NB: not only the string below but also complex.h and numpy.h rely on this order.
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> SFINAE <font color='#5555FF'>=</font> <font color='#0000FF'><u>void</u></font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='is_fmt_numeric'></a>is_fmt_numeric</b> <b>{</b> <font color='#0000FF'>static</font> constexpr <font color='#0000FF'><u>bool</u></font> value <font color='#5555FF'>=</font> <font color='#979000'>false</font>; <b>}</b>;
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='is_fmt_numeric'></a>is_fmt_numeric</b><font color='#5555FF'>&lt;</font>T, enable_if_t<font color='#5555FF'>&lt;</font>std::is_arithmetic<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <b>{</b>
    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'><u>bool</u></font> value <font color='#5555FF'>=</font> <font color='#979000'>true</font>;
    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'><u>int</u></font> index <font color='#5555FF'>=</font> std::is_same<font color='#5555FF'>&lt;</font>T, <font color='#0000FF'><u>bool</u></font><font color='#5555FF'>&gt;</font>::value ? <font color='#979000'>0</font> : <font color='#979000'>1</font> <font color='#5555FF'>+</font> <font face='Lucida Console'>(</font>
        std::is_integral<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::value ? detail::<font color='#BB00BB'>log2</font><font face='Lucida Console'>(</font><font color='#0000FF'>sizeof</font><font face='Lucida Console'>(</font>T<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>*</font><font color='#979000'>2</font> <font color='#5555FF'>+</font> std::is_unsigned<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::value : <font color='#979000'>8</font> <font color='#5555FF'>+</font> <font face='Lucida Console'>(</font>
        std::is_same<font color='#5555FF'>&lt;</font>T, <font color='#0000FF'><u>double</u></font><font color='#5555FF'>&gt;</font>::value ? <font color='#979000'>1</font> : std::is_same<font color='#5555FF'>&lt;</font>T, <font color='#0000FF'><u>long</u></font> <font color='#0000FF'><u>double</u></font><font color='#5555FF'>&gt;</font>::value ? <font color='#979000'>2</font> : <font color='#979000'>0</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b>}</b>;
<b><a name='NAMESPACE_END'></a>NAMESPACE_END</b><font face='Lucida Console'>(</font>detail<font face='Lucida Console'>)</font>

<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='format_descriptor'></a>format_descriptor</b><font color='#5555FF'>&lt;</font>T, detail::enable_if_t<font color='#5555FF'>&lt;</font>std::is_arithmetic<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <b>{</b>
    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'>const</font> <font color='#0000FF'><u>char</u></font> c <font color='#5555FF'>=</font> "<font color='#CC0000'>?bBhHiIqQfdg</font>"[detail::is_fmt_numeric<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::index];
    <font color='#0000FF'>static</font> constexpr <font color='#0000FF'>const</font> <font color='#0000FF'><u>char</u></font> value[<font color='#979000'>2</font>] <font color='#5555FF'>=</font> <b>{</b> c, '<font color='#FF0000'>\0</font>' <b>}</b>;
    <font color='#0000FF'>static</font> std::string <b><a name='format'></a>format</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> std::<font color='#BB00BB'>string</font><font face='Lucida Console'>(</font><font color='#979000'>1</font>, c<font face='Lucida Console'>)</font>; <b>}</b>
<b>}</b>;

<font color='#0000FF'>#if</font> <font color='#5555FF'>!</font>defined<font face='Lucida Console'>(</font>PYBIND11_CPP17<font face='Lucida Console'>)</font>

<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> constexpr <font color='#0000FF'>const</font> <font color='#0000FF'><u>char</u></font> format_descriptor<font color='#5555FF'>&lt;</font>
    T, detail::enable_if_t<font color='#5555FF'>&lt;</font>std::is_arithmetic<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>::value[<font color='#979000'>2</font>];

<font color='#0000FF'>#endif</font>

<font color='#009900'>/// RAII wrapper that temporarily clears any Python error state
</font><font color='#0000FF'>struct</font> <b><a name='error_scope'></a>error_scope</b> <b>{</b>
    PyObject <font color='#5555FF'>*</font>type, <font color='#5555FF'>*</font>value, <font color='#5555FF'>*</font>trace;
    <b><a name='error_scope'></a>error_scope</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>{</b> <font color='#BB00BB'>PyErr_Fetch</font><font face='Lucida Console'>(</font><font color='#5555FF'>&amp;</font>type, <font color='#5555FF'>&amp;</font>value, <font color='#5555FF'>&amp;</font>trace<font face='Lucida Console'>)</font>; <b>}</b>
    ~<b><a name='error_scope'></a>error_scope</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>{</b> <font color='#BB00BB'>PyErr_Restore</font><font face='Lucida Console'>(</font>type, value, trace<font face='Lucida Console'>)</font>; <b>}</b>
<b>}</b>;

<font color='#009900'>/// Dummy destructor wrapper that can be used to expose classes with a private destructor
</font><font color='#0000FF'>struct</font> <b><a name='nodelete'></a>nodelete</b> <b>{</b> <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='operator'></a>operator</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>T<font color='#5555FF'>*</font><font face='Lucida Console'>)</font> <b>{</b> <b>}</b> <b>}</b>;

<font color='#009900'>// overload_cast requires variable templates: C++14
</font><font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PYBIND11_CPP14<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PYBIND11_OVERLOAD_CAST <font color='#979000'>1</font>

<b><a name='NAMESPACE_BEGIN'></a>NAMESPACE_BEGIN</b><font face='Lucida Console'>(</font>detail<font face='Lucida Console'>)</font>
<font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font>... Args<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>struct</font> <b><a name='overload_cast_impl'></a>overload_cast_impl</b> <b>{</b>
    constexpr <b><a name='overload_cast_impl'></a>overload_cast_impl</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>{</b><b>}</b> <font color='#009900'>// MSVC 2015 needs this
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> Return<font color='#5555FF'>&gt;</font>
    constexpr <font color='#0000FF'>auto</font> <b><a name='operator'></a>operator</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font color='#BB00BB'>Return</font> <font face='Lucida Console'>(</font><font color='#5555FF'>*</font>pf<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>Args...<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font> noexcept
                              <font color='#5555FF'>-</font><font color='#5555FF'>&gt;</font> <b><a name='decltype'></a>decltype</b><font face='Lucida Console'>(</font>pf<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> pf; <b>}</b>

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> Return, <font color='#0000FF'>typename</font> Class<font color='#5555FF'>&gt;</font>
    constexpr <font color='#0000FF'>auto</font> <b><a name='operator'></a>operator</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font color='#BB00BB'>Return</font> <font face='Lucida Console'>(</font>Class::<font color='#5555FF'>*</font>pmf<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>Args...<font face='Lucida Console'>)</font>, std::false_type <font color='#5555FF'>=</font> <b>{</b><b>}</b><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font> noexcept
                              <font color='#5555FF'>-</font><font color='#5555FF'>&gt;</font> <b><a name='decltype'></a>decltype</b><font face='Lucida Console'>(</font>pmf<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> pmf; <b>}</b>

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> Return, <font color='#0000FF'>typename</font> Class<font color='#5555FF'>&gt;</font>
    constexpr <font color='#0000FF'>auto</font> <b><a name='operator'></a>operator</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font color='#BB00BB'>Return</font> <font face='Lucida Console'>(</font>Class::<font color='#5555FF'>*</font>pmf<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>Args...<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>, std::true_type<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font> noexcept
                              <font color='#5555FF'>-</font><font color='#5555FF'>&gt;</font> <b><a name='decltype'></a>decltype</b><font face='Lucida Console'>(</font>pmf<font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> pmf; <b>}</b>
<b>}</b>;
<b><a name='NAMESPACE_END'></a>NAMESPACE_END</b><font face='Lucida Console'>(</font>detail<font face='Lucida Console'>)</font>

<font color='#009900'>/// Syntax sugar for resolving overloaded function pointers:
</font><font color='#009900'>///  - regular: static_cast&lt;Return (Class::*)(Arg0, Arg1, Arg2)&gt;(&amp;Class::func)
</font><font color='#009900'>///  - sweet:   overload_cast&lt;Arg0, Arg1, Arg2&gt;(&amp;Class::func)
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font>... Args<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>static</font> constexpr detail::overload_cast_impl<font color='#5555FF'>&lt;</font>Args...<font color='#5555FF'>&gt;</font> overload_cast <font color='#5555FF'>=</font> <b>{</b><b>}</b>;
<font color='#009900'>// MSVC 2015 only accepts this particular initialization syntax for this variable template.
</font>
<font color='#009900'>/// Const member function selector for overload_cast
</font><font color='#009900'>///  - regular: static_cast&lt;Return (Class::*)(Arg) const&gt;(&amp;Class::func)
</font><font color='#009900'>///  - sweet:   overload_cast&lt;Arg&gt;(&amp;Class::func, const_)
</font><font color='#0000FF'>static</font> constexpr <font color='#0000FF'>auto</font> const_ <font color='#5555FF'>=</font> std::true_type<b>{</b><b>}</b>;

<font color='#0000FF'>#else</font> <font color='#009900'>// no overload_cast: providing something that static_assert-fails:
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font>... Args<font color='#5555FF'>&gt;</font> <font color='#0000FF'>struct</font> <b><a name='overload_cast'></a>overload_cast</b> <b>{</b>
    <b><a name='static_assert'></a>static_assert</b><font face='Lucida Console'>(</font>detail::deferred_t<font color='#5555FF'>&lt;</font>std::false_type, Args...<font color='#5555FF'>&gt;</font>::value,
                  "<font color='#CC0000'>pybind11::overload_cast&lt;...&gt; requires compiling in C++14 mode</font>"<font face='Lucida Console'>)</font>;
<b>}</b>;
<font color='#0000FF'>#endif</font> <font color='#009900'>// overload_cast
</font>
<b><a name='NAMESPACE_BEGIN'></a>NAMESPACE_BEGIN</b><font face='Lucida Console'>(</font>detail<font face='Lucida Console'>)</font>

<font color='#009900'>// Adaptor for converting arbitrary container arguments into a vector; implicitly convertible from
</font><font color='#009900'>// any standard container (or C-style array) supporting std::begin/std::end, any singleton
</font><font color='#009900'>// arithmetic type (if T is arithmetic), or explicitly constructible from an iterator pair.
</font><font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>class</font> <b><a name='any_container'></a>any_container</b> <b>{</b>
    std::vector<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font> v;
<font color='#0000FF'>public</font>:
    <b><a name='any_container'></a>any_container</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#5555FF'>=</font> <font color='#0000FF'>default</font>;

    <font color='#009900'>// Can construct from a pair of iterators
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> It, <font color='#0000FF'>typename</font> <font color='#5555FF'>=</font> enable_if_t<font color='#5555FF'>&lt;</font>is_input_iterator<font color='#5555FF'>&lt;</font>It<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>
    <b><a name='any_container'></a>any_container</b><font face='Lucida Console'>(</font>It first, It last<font face='Lucida Console'>)</font> : v<font face='Lucida Console'>(</font>first, last<font face='Lucida Console'>)</font> <b>{</b> <b>}</b>

    <font color='#009900'>// Implicit conversion constructor from any arbitrary container type with values convertible to T
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> Container, <font color='#0000FF'>typename</font> <font color='#5555FF'>=</font> enable_if_t<font color='#5555FF'>&lt;</font>std::is_convertible<font color='#5555FF'>&lt;</font><b><a name='decltype'></a>decltype</b><font face='Lucida Console'>(</font><font color='#5555FF'>*</font>std::<font color='#BB00BB'>begin</font><font face='Lucida Console'>(</font>std::declval<font color='#5555FF'>&lt;</font><font color='#0000FF'>const</font> Container <font color='#5555FF'>&amp;</font><font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>, T<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>
    <b><a name='any_container'></a>any_container</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> Container <font color='#5555FF'>&amp;</font>c<font face='Lucida Console'>)</font> : any_container<font face='Lucida Console'>(</font>std::begin<font face='Lucida Console'>(</font>c<font face='Lucida Console'>)</font>, std::end<font face='Lucida Console'>(</font>c<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <b>{</b> <b>}</b>

    <font color='#009900'>// initializer_list's aren't deducible, so don't get matched by the above template; we need this
</font>    <font color='#009900'>// to explicitly allow implicit conversion from one:
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> TIn, <font color='#0000FF'>typename</font> <font color='#5555FF'>=</font> enable_if_t<font color='#5555FF'>&lt;</font>std::is_convertible<font color='#5555FF'>&lt;</font>TIn, T<font color='#5555FF'>&gt;</font>::value<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>
    <b><a name='any_container'></a>any_container</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> std::initializer_list<font color='#5555FF'>&lt;</font>TIn<font color='#5555FF'>&gt;</font> <font color='#5555FF'>&amp;</font>c<font face='Lucida Console'>)</font> : any_container<font face='Lucida Console'>(</font>c.begin<font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>, c.end<font face='Lucida Console'>(</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <b>{</b> <b>}</b>

    <font color='#009900'>// Avoid copying if given an rvalue vector of the correct type.
</font>    <b><a name='any_container'></a>any_container</b><font face='Lucida Console'>(</font>std::vector<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font> <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font>v<font face='Lucida Console'>)</font> : v<font face='Lucida Console'>(</font>std::move<font face='Lucida Console'>(</font>v<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <b>{</b> <b>}</b>

    <font color='#009900'>// Moves the vector out of an rvalue any_container
</font>    <b><a name='operator'></a>operator</b> std::vector<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font> <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&amp;</font><font color='#5555FF'>&amp;</font> <b>{</b> <font color='#0000FF'>return</font> std::<font color='#BB00BB'>move</font><font face='Lucida Console'>(</font>v<font face='Lucida Console'>)</font>; <b>}</b>

    <font color='#009900'>// Dereferencing obtains a reference to the underlying vector
</font>    std::vector<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font> <font color='#5555FF'>&amp;</font><b><a name='operator'></a>operator</b><font color='#5555FF'>*</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> v; <b>}</b>
    <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font> <font color='#5555FF'>&amp;</font><b><a name='operator'></a>operator</b><font color='#5555FF'>*</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font> <b>{</b> <font color='#0000FF'>return</font> v; <b>}</b>

    <font color='#009900'>// -&gt; lets you call methods on the underlying vector
</font>    std::vector<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font> <font color='#5555FF'>*</font><b><a name='operator'></a>operator</b><font color='#5555FF'>-</font><font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <b>{</b> <font color='#0000FF'>return</font> <font color='#5555FF'>&amp;</font>v; <b>}</b>
    <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font> <font color='#5555FF'>*</font><b><a name='operator'></a>operator</b><font color='#5555FF'>-</font><font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font> <b>{</b> <font color='#0000FF'>return</font> <font color='#5555FF'>&amp;</font>v; <b>}</b>
<b>}</b>;

<b><a name='NAMESPACE_END'></a>NAMESPACE_END</b><font face='Lucida Console'>(</font>detail<font face='Lucida Console'>)</font>



<b><a name='NAMESPACE_END'></a>NAMESPACE_END</b><font face='Lucida Console'>(</font>PYBIND11_NAMESPACE<font face='Lucida Console'>)</font>

</pre></body></html>